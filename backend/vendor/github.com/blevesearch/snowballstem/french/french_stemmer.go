//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package french

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "col", A: -1, B: -1, F: nil},
	{Str: "par", A: -1, B: -1, F: nil},
	{Str: "tap", A: -1, B: -1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 4, F: nil},
	{Str: "I", A: 0, B: 1, F: nil},
	{Str: "U", A: 0, B: 2, F: nil},
	{Str: "Y", A: 0, B: 3, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "iqU", A: -1, B: 3, F: nil},
	{Str: "abl", A: -1, B: 3, F: nil},
	{Str: "I\u00E8r", A: -1, B: 4, F: nil},
	{Str: "i\u00E8r", A: -1, B: 4, F: nil},
	{Str: "eus", A: -1, B: 2, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: 2, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 3, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "iqUe", A: -1, B: 1, F: nil},
	{Str: "atrice", A: -1, B: 2, F: nil},
	{Str: "ance", A: -1, B: 1, F: nil},
	{Str: "ence", A: -1, B: 5, F: nil},
	{Str: "logie", A: -1, B: 3, F: nil},
	{Str: "able", A: -1, B: 1, F: nil},
	{Str: "isme", A: -1, B: 1, F: nil},
	{Str: "euse", A: -1, B: 11, F: nil},
	{Str: "iste", A: -1, B: 1, F: nil},
	{Str: "ive", A: -1, B: 8, F: nil},
	{Str: "if", A: -1, B: 8, F: nil},
	{Str: "usion", A: -1, B: 4, F: nil},
	{Str: "ation", A: -1, B: 2, F: nil},
	{Str: "ution", A: -1, B: 4, F: nil},
	{Str: "ateur", A: -1, B: 2, F: nil},
	{Str: "iqUes", A: -1, B: 1, F: nil},
	{Str: "atrices", A: -1, B: 2, F: nil},
	{Str: "ances", A: -1, B: 1, F: nil},
	{Str: "ences", A: -1, B: 5, F: nil},
	{Str: "logies", A: -1, B: 3, F: nil},
	{Str: "ables", A: -1, B: 1, F: nil},
	{Str: "ismes", A: -1, B: 1, F: nil},
	{Str: "euses", A: -1, B: 11, F: nil},
	{Str: "istes", A: -1, B: 1, F: nil},
	{Str: "ives", A: -1, B: 8, F: nil},
	{Str: "ifs", A: -1, B: 8, F: nil},
	{Str: "usions", A: -1, B: 4, F: nil},
	{Str: "ations", A: -1, B: 2, F: nil},
	{Str: "utions", A: -1, B: 4, F: nil},
	{Str: "ateurs", A: -1, B: 2, F: nil},
	{Str: "ments", A: -1, B: 15, F: nil},
	{Str: "ements", A: 30, B: 6, F: nil},
	{Str: "issements", A: 31, B: 12, F: nil},
	{Str: "it\u00E9s", A: -1, B: 7, F: nil},
	{Str: "ment", A: -1, B: 15, F: nil},
	{Str: "ement", A: 34, B: 6, F: nil},
	{Str: "issement", A: 35, B: 12, F: nil},
	{Str: "amment", A: 34, B: 13, F: nil},
	{Str: "emment", A: 34, B: 14, F: nil},
	{Str: "aux", A: -1, B: 10, F: nil},
	{Str: "eaux", A: 39, B: 9, F: nil},
	{Str: "eux", A: -1, B: 1, F: nil},
	{Str: "it\u00E9", A: -1, B: 7, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "ira", A: -1, B: 1, F: nil},
	{Str: "ie", A: -1, B: 1, F: nil},
	{Str: "isse", A: -1, B: 1, F: nil},
	{Str: "issante", A: -1, B: 1, F: nil},
	{Str: "i", A: -1, B: 1, F: nil},
	{Str: "irai", A: 4, B: 1, F: nil},
	{Str: "ir", A: -1, B: 1, F: nil},
	{Str: "iras", A: -1, B: 1, F: nil},
	{Str: "ies", A: -1, B: 1, F: nil},
	{Str: "\u00EEmes", A: -1, B: 1, F: nil},
	{Str: "isses", A: -1, B: 1, F: nil},
	{Str: "issantes", A: -1, B: 1, F: nil},
	{Str: "\u00EEtes", A: -1, B: 1, F: nil},
	{Str: "is", A: -1, B: 1, F: nil},
	{Str: "irais", A: 13, B: 1, F: nil},
	{Str: "issais", A: 13, B: 1, F: nil},
	{Str: "irions", A: -1, B: 1, F: nil},
	{Str: "issions", A: -1, B: 1, F: nil},
	{Str: "irons", A: -1, B: 1, F: nil},
	{Str: "issons", A: -1, B: 1, F: nil},
	{Str: "issants", A: -1, B: 1, F: nil},
	{Str: "it", A: -1, B: 1, F: nil},
	{Str: "irait", A: 21, B: 1, F: nil},
	{Str: "issait", A: 21, B: 1, F: nil},
	{Str: "issant", A: -1, B: 1, F: nil},
	{Str: "iraIent", A: -1, B: 1, F: nil},
	{Str: "issaIent", A: -1, B: 1, F: nil},
	{Str: "irent", A: -1, B: 1, F: nil},
	{Str: "issent", A: -1, B: 1, F: nil},
	{Str: "iront", A: -1, B: 1, F: nil},
	{Str: "\u00EEt", A: -1, B: 1, F: nil},
	{Str: "iriez", A: -1, B: 1, F: nil},
	{Str: "issiez", A: -1, B: 1, F: nil},
	{Str: "irez", A: -1, B: 1, F: nil},
	{Str: "issez", A: -1, B: 1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 3, F: nil},
	{Str: "era", A: 0, B: 2, F: nil},
	{Str: "asse", A: -1, B: 3, F: nil},
	{Str: "ante", A: -1, B: 3, F: nil},
	{Str: "\u00E9e", A: -1, B: 2, F: nil},
	{Str: "ai", A: -1, B: 3, F: nil},
	{Str: "erai", A: 5, B: 2, F: nil},
	{Str: "er", A: -1, B: 2, F: nil},
	{Str: "as", A: -1, B: 3, F: nil},
	{Str: "eras", A: 8, B: 2, F: nil},
	{Str: "\u00E2mes", A: -1, B: 3, F: nil},
	{Str: "asses", A: -1, B: 3, F: nil},
	{Str: "antes", A: -1, B: 3, F: nil},
	{Str: "\u00E2tes", A: -1, B: 3, F: nil},
	{Str: "\u00E9es", A: -1, B: 2, F: nil},
	{Str: "ais", A: -1, B: 3, F: nil},
	{Str: "erais", A: 15, B: 2, F: nil},
	{Str: "ions", A: -1, B: 1, F: nil},
	{Str: "erions", A: 17, B: 2, F: nil},
	{Str: "assions", A: 17, B: 3, F: nil},
	{Str: "erons", A: -1, B: 2, F: nil},
	{Str: "ants", A: -1, B: 3, F: nil},
	{Str: "\u00E9s", A: -1, B: 2, F: nil},
	{Str: "ait", A: -1, B: 3, F: nil},
	{Str: "erait", A: 23, B: 2, F: nil},
	{Str: "ant", A: -1, B: 3, F: nil},
	{Str: "aIent", A: -1, B: 3, F: nil},
	{Str: "eraIent", A: 26, B: 2, F: nil},
	{Str: "\u00E8rent", A: -1, B: 2, F: nil},
	{Str: "assent", A: -1, B: 3, F: nil},
	{Str: "eront", A: -1, B: 2, F: nil},
	{Str: "\u00E2t", A: -1, B: 3, F: nil},
	{Str: "ez", A: -1, B: 2, F: nil},
	{Str: "iez", A: 32, B: 2, F: nil},
	{Str: "eriez", A: 33, B: 2, F: nil},
	{Str: "assiez", A: 33, B: 3, F: nil},
	{Str: "erez", A: 32, B: 2, F: nil},
	{Str: "\u00E9", A: -1, B: 2, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "e", A: -1, B: 3, F: nil},
	{Str: "I\u00E8re", A: 0, B: 2, F: nil},
	{Str: "i\u00E8re", A: 0, B: 2, F: nil},
	{Str: "ion", A: -1, B: 1, F: nil},
	{Str: "Ier", A: -1, B: 2, F: nil},
	{Str: "ier", A: -1, B: 2, F: nil},
	{Str: "\u00EB", A: -1, B: 4, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "ell", A: -1, B: -1, F: nil},
	{Str: "eill", A: -1, B: -1, F: nil},
	{Str: "enn", A: -1, B: -1, F: nil},
	{Str: "onn", A: -1, B: -1, F: nil},
	{Str: "ett", A: -1, B: -1, F: nil},
}

var G_v = []byte{17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 130, 103, 8, 5}

var G_keep_with_s = []byte{1, 65, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// repeat, line 38
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// goto, line 38
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					// (, line 38
					// or, line 44
				lab4:
					for {
						var v_3 = env.Cursor
					lab5:
						for {
							// (, line 40
							if !env.InGrouping(G_v, 97, 251) {
								break lab5
							}
							// [, line 40
							env.Bra = env.Cursor
							// or, line 40
						lab6:
							for {
								var v_4 = env.Cursor
							lab7:
								for {
									// (, line 40
									// literal, line 40
									if !env.EqS("u") {
										break lab7
									}
									// ], line 40
									env.Ket = env.Cursor
									if !env.InGrouping(G_v, 97, 251) {
										break lab7
									}
									// <-, line 40
									if !env.SliceFrom("U") {
										return false
									}
									break lab6
								}
								env.Cursor = v_4
							lab8:
								for {
									// (, line 41
									// literal, line 41
									if !env.EqS("i") {
										break lab8
									}
									// ], line 41
									env.Ket = env.Cursor
									if !env.InGrouping(G_v, 97, 251) {
										break lab8
									}
									// <-, line 41
									if !env.SliceFrom("I") {
										return false
									}
									break lab6
								}
								env.Cursor = v_4
								// (, line 42
								// literal, line 42
								if !env.EqS("y") {
									break lab5
								}
								// ], line 42
								env.Ket = env.Cursor
								// <-, line 42
								if !env.SliceFrom("Y") {
									return false
								}
								break lab6
							}
							break lab4
						}
						env.Cursor = v_3
					lab9:
						for {
							// (, line 45
							// [, line 45
							env.Bra = env.Cursor
							// literal, line 45
							if !env.EqS("y") {
								break lab9
							}
							// ], line 45
							env.Ket = env.Cursor
							if !env.InGrouping(G_v, 97, 251) {
								break lab9
							}
							// <-, line 45
							if !env.SliceFrom("Y") {
								return false
							}
							break lab4
						}
						env.Cursor = v_3
						// (, line 47
						// literal, line 47
						if !env.EqS("q") {
							break lab3
						}
						// [, line 47
						env.Bra = env.Cursor
						// literal, line 47
						if !env.EqS("u") {
							break lab3
						}
						// ], line 47
						env.Ket = env.Cursor
						// <-, line 47
						if !env.SliceFrom("U") {
							return false
						}
						break lab4
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 50
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 56
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 56
		// or, line 58
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				// (, line 57
				if !env.InGrouping(G_v, 97, 251) {
					break lab2
				}
				if !env.InGrouping(G_v, 97, 251) {
					break lab2
				}
				// next, line 57
				if env.Cursor >= env.Limit {
					break lab2
				}
				env.NextChar()
				break lab1
			}
			env.Cursor = v_2
		lab3:
			for {
				// among, line 59
				if env.FindAmong(A_0, context) == 0 {
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			// (, line 66
			// next, line 66
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
			// gopast, line 66
		golab4:
			for {
			lab5:
				for {
					if !env.InGrouping(G_v, 97, 251) {
						break lab5
					}
					break golab4
				}
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
			}
			break lab1
		}
		// setmark pV, line 67
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	// do, line 69
	var v_4 = env.Cursor
lab6:
	for {
		// (, line 69
		// gopast, line 70
	golab7:
		for {
		lab8:
			for {
				if !env.InGrouping(G_v, 97, 251) {
					break lab8
				}
				break golab7
			}
			if env.Cursor >= env.Limit {
				break lab6
			}
			env.NextChar()
		}
		// gopast, line 70
	golab9:
		for {
		lab10:
			for {
				if !env.OutGrouping(G_v, 97, 251) {
					break lab10
				}
				break golab9
			}
			if env.Cursor >= env.Limit {
				break lab6
			}
			env.NextChar()
		}
		// setmark p1, line 70
		context.i_p1 = env.Cursor
		// gopast, line 71
	golab11:
		for {
		lab12:
			for {
				if !env.InGrouping(G_v, 97, 251) {
					break lab12
				}
				break golab11
			}
			if env.Cursor >= env.Limit {
				break lab6
			}
			env.NextChar()
		}
		// gopast, line 71
	golab13:
		for {
		lab14:
			for {
				if !env.OutGrouping(G_v, 97, 251) {
					break lab14
				}
				break golab13
			}
			if env.Cursor >= env.Limit {
				break lab6
			}
			env.NextChar()
		}
		// setmark p2, line 71
		context.i_p2 = env.Cursor
		break lab6
	}
	env.Cursor = v_4
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// repeat, line 75
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 75
			// [, line 77
			env.Bra = env.Cursor
			// substring, line 77
			among_var = env.FindAmong(A_1, context)
			if among_var == 0 {
				break lab1
			}
			// ], line 77
			env.Ket = env.Cursor
			if among_var == 0 {
				break lab1
			} else if among_var == 1 {
				// (, line 78
				// <-, line 78
				if !env.SliceFrom("i") {
					return false
				}
			} else if among_var == 2 {
				// (, line 79
				// <-, line 79
				if !env.SliceFrom("u") {
					return false
				}
			} else if among_var == 3 {
				// (, line 80
				// <-, line 80
				if !env.SliceFrom("y") {
					return false
				}
			} else if among_var == 4 {
				// (, line 81
				// next, line 81
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 91
	// [, line 92
	env.Ket = env.Cursor
	// substring, line 92
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		return false
	}
	// ], line 92
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 96
		// call R2, line 96
		if !r_R2(env, context) {
			return false
		}
		// delete, line 96
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 99
		// call R2, line 99
		if !r_R2(env, context) {
			return false
		}
		// delete, line 99
		if !env.SliceDel() {
			return false
		}
		// try, line 100
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 100
			// [, line 100
			env.Ket = env.Cursor
			// literal, line 100
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// ], line 100
			env.Bra = env.Cursor
			// or, line 100
		lab1:
			for {
				var v_2 = env.Limit - env.Cursor
			lab2:
				for {
					// (, line 100
					// call R2, line 100
					if !r_R2(env, context) {
						break lab2
					}
					// delete, line 100
					if !env.SliceDel() {
						return false
					}
					break lab1
				}
				env.Cursor = env.Limit - v_2
				// <-, line 100
				if !env.SliceFrom("iqU") {
					return false
				}
				break lab1
			}
			break lab0
		}
	} else if among_var == 3 {
		// (, line 104
		// call R2, line 104
		if !r_R2(env, context) {
			return false
		}
		// <-, line 104
		if !env.SliceFrom("log") {
			return false
		}
	} else if among_var == 4 {
		// (, line 107
		// call R2, line 107
		if !r_R2(env, context) {
			return false
		}
		// <-, line 107
		if !env.SliceFrom("u") {
			return false
		}
	} else if among_var == 5 {
		// (, line 110
		// call R2, line 110
		if !r_R2(env, context) {
			return false
		}
		// <-, line 110
		if !env.SliceFrom("ent") {
			return false
		}
	} else if among_var == 6 {
		// (, line 113
		// call RV, line 114
		if !r_RV(env, context) {
			return false
		}
		// delete, line 114
		if !env.SliceDel() {
			return false
		}
		// try, line 115
		var v_3 = env.Limit - env.Cursor
	lab3:
		for {
			// (, line 115
			// [, line 116
			env.Ket = env.Cursor
			// substring, line 116
			among_var = env.FindAmongB(A_2, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab3
			}
			// ], line 116
			env.Bra = env.Cursor
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab3
			} else if among_var == 1 {
				// (, line 117
				// call R2, line 117
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				// delete, line 117
				if !env.SliceDel() {
					return false
				}
				// [, line 117
				env.Ket = env.Cursor
				// literal, line 117
				if !env.EqSB("at") {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				// ], line 117
				env.Bra = env.Cursor
				// call R2, line 117
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				// delete, line 117
				if !env.SliceDel() {
					return false
				}
			} else if among_var == 2 {
				// (, line 118
				// or, line 118
			lab4:
				for {
					var v_4 = env.Limit - env.Cursor
				lab5:
					for {
						// (, line 118
						// call R2, line 118
						if !r_R2(env, context) {
							break lab5
						}
						// delete, line 118
						if !env.SliceDel() {
							return false
						}
						break lab4
					}
					env.Cursor = env.Limit - v_4
					// (, line 118
					// call R1, line 118
					if !r_R1(env, context) {
						env.Cursor = env.Limit - v_3
						break lab3
					}
					// <-, line 118
					if !env.SliceFrom("eux") {
						return false
					}
					break lab4
				}
			} else if among_var == 3 {
				// (, line 120
				// call R2, line 120
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				// delete, line 120
				if !env.SliceDel() {
					return false
				}
			} else if among_var == 4 {
				// (, line 122
				// call RV, line 122
				if !r_RV(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				// <-, line 122
				if !env.SliceFrom("i") {
					return false
				}
			}
			break lab3
		}
	} else if among_var == 7 {
		// (, line 128
		// call R2, line 129
		if !r_R2(env, context) {
			return false
		}
		// delete, line 129
		if !env.SliceDel() {
			return false
		}
		// try, line 130
		var v_5 = env.Limit - env.Cursor
	lab6:
		for {
			// (, line 130
			// [, line 131
			env.Ket = env.Cursor
			// substring, line 131
			among_var = env.FindAmongB(A_3, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_5
				break lab6
			}
			// ], line 131
			env.Bra = env.Cursor
			if among_var == 0 {
				env.Cursor = env.Limit - v_5
				break lab6
			} else if among_var == 1 {
				// (, line 132
				// or, line 132
			lab7:
				for {
					var v_6 = env.Limit - env.Cursor
				lab8:
					for {
						// (, line 132
						// call R2, line 132
						if !r_R2(env, context) {
							break lab8
						}
						// delete, line 132
						if !env.SliceDel() {
							return false
						}
						break lab7
					}
					env.Cursor = env.Limit - v_6
					// <-, line 132
					if !env.SliceFrom("abl") {
						return false
					}
					break lab7
				}
			} else if among_var == 2 {
				// (, line 133
				// or, line 133
			lab9:
				for {
					var v_7 = env.Limit - env.Cursor
				lab10:
					for {
						// (, line 133
						// call R2, line 133
						if !r_R2(env, context) {
							break lab10
						}
						// delete, line 133
						if !env.SliceDel() {
							return false
						}
						break lab9
					}
					env.Cursor = env.Limit - v_7
					// <-, line 133
					if !env.SliceFrom("iqU") {
						return false
					}
					break lab9
				}
			} else if among_var == 3 {
				// (, line 134
				// call R2, line 134
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_5
					break lab6
				}
				// delete, line 134
				if !env.SliceDel() {
					return false
				}
			}
			break lab6
		}
	} else if among_var == 8 {
		// (, line 140
		// call R2, line 141
		if !r_R2(env, context) {
			return false
		}
		// delete, line 141
		if !env.SliceDel() {
			return false
		}
		// try, line 142
		var v_8 = env.Limit - env.Cursor
	lab11:
		for {
			// (, line 142
			// [, line 142
			env.Ket = env.Cursor
			// literal, line 142
			if !env.EqSB("at") {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			// ], line 142
			env.Bra = env.Cursor
			// call R2, line 142
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			// delete, line 142
			if !env.SliceDel() {
				return false
			}
			// [, line 142
			env.Ket = env.Cursor
			// literal, line 142
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			// ], line 142
			env.Bra = env.Cursor
			// or, line 142
		lab12:
			for {
				var v_9 = env.Limit - env.Cursor
			lab13:
				for {
					// (, line 142
					// call R2, line 142
					if !r_R2(env, context) {
						break lab13
					}
					// delete, line 142
					if !env.SliceDel() {
						return false
					}
					break lab12
				}
				env.Cursor = env.Limit - v_9
				// <-, line 142
				if !env.SliceFrom("iqU") {
					return false
				}
				break lab12
			}
			break lab11
		}
	} else if among_var == 9 {
		// (, line 144
		// <-, line 144
		if !env.SliceFrom("eau") {
			return false
		}
	} else if among_var == 10 {
		// (, line 145
		// call R1, line 145
		if !r_R1(env, context) {
			return false
		}
		// <-, line 145
		if !env.SliceFrom("al") {
			return false
		}
	} else if among_var == 11 {
		// (, line 147
		// or, line 147
	lab14:
		for {
			var v_10 = env.Limit - env.Cursor
		lab15:
			for {
				// (, line 147
				// call R2, line 147
				if !r_R2(env, context) {
					break lab15
				}
				// delete, line 147
				if !env.SliceDel() {
					return false
				}
				break lab14
			}
			env.Cursor = env.Limit - v_10
			// (, line 147
			// call R1, line 147
			if !r_R1(env, context) {
				return false
			}
			// <-, line 147
			if !env.SliceFrom("eux") {
				return false
			}
			break lab14
		}
	} else if among_var == 12 {
		// (, line 150
		// call R1, line 150
		if !r_R1(env, context) {
			return false
		}
		if !env.OutGroupingB(G_v, 97, 251) {
			return false
		}
		// delete, line 150
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 13 {
		// (, line 155
		// call RV, line 155
		if !r_RV(env, context) {
			return false
		}
		// fail, line 155
		// (, line 155
		// <-, line 155
		if !env.SliceFrom("ant") {
			return false
		}
		return false
	} else if among_var == 14 {
		// (, line 156
		// call RV, line 156
		if !r_RV(env, context) {
			return false
		}
		// fail, line 156
		// (, line 156
		// <-, line 156
		if !env.SliceFrom("ent") {
			return false
		}
		return false
	} else if among_var == 15 {
		// (, line 158
		// test, line 158
		var v_11 = env.Limit - env.Cursor
		// (, line 158
		if !env.InGroupingB(G_v, 97, 251) {
			return false
		}
		// call RV, line 158
		if !r_RV(env, context) {
			return false
		}
		env.Cursor = env.Limit - v_11
		// fail, line 158
		// (, line 158
		// delete, line 158
		if !env.SliceDel() {
			return false
		}
		return false
	}
	return true
}

func r_i_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// setlimit, line 163
	var v_1 = env.Limit - env.Cursor
	// tomark, line 163
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 163
	// [, line 164
	env.Ket = env.Cursor
	// substring, line 164
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 164
	env.Bra = env.Cursor
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	} else if among_var == 1 {
		// (, line 170
		if !env.OutGroupingB(G_v, 97, 251) {
			env.LimitBackward = v_2
			return false
		}
		// delete, line 170
		if !env.SliceDel() {
			return false
		}
	}
	env.LimitBackward = v_2
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// setlimit, line 174
	var v_1 = env.Limit - env.Cursor
	// tomark, line 174
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 174
	// [, line 175
	env.Ket = env.Cursor
	// substring, line 175
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 175
	env.Bra = env.Cursor
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	} else if among_var == 1 {
		// (, line 177
		// call R2, line 177
		if !r_R2(env, context) {
			env.LimitBackward = v_2
			return false
		}
		// delete, line 177
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 185
		// delete, line 185
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 3 {
		// (, line 190
		// delete, line 190
		if !env.SliceDel() {
			return false
		}
		// try, line 191
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 191
			// [, line 191
			env.Ket = env.Cursor
			// literal, line 191
			if !env.EqSB("e") {
				env.Cursor = env.Limit - v_3
				break lab0
			}
			// ], line 191
			env.Bra = env.Cursor
			// delete, line 191
			if !env.SliceDel() {
				return false
			}
			break lab0
		}
	}
	env.LimitBackward = v_2
	return true
}

func r_residual_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 198
	// try, line 199
	var v_1 = env.Limit - env.Cursor
lab0:
	for {
		// (, line 199
		// [, line 199
		env.Ket = env.Cursor
		// literal, line 199
		if !env.EqSB("s") {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// ], line 199
		env.Bra = env.Cursor
		// test, line 199
		var v_2 = env.Limit - env.Cursor
		if !env.OutGroupingB(G_keep_with_s, 97, 232) {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		env.Cursor = env.Limit - v_2
		// delete, line 199
		if !env.SliceDel() {
			return false
		}
		break lab0
	}
	// setlimit, line 200
	var v_3 = env.Limit - env.Cursor
	// tomark, line 200
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_4 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_3
	// (, line 200
	// [, line 201
	env.Ket = env.Cursor
	// substring, line 201
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_4
		return false
	}
	// ], line 201
	env.Bra = env.Cursor
	if among_var == 0 {
		env.LimitBackward = v_4
		return false
	} else if among_var == 1 {
		// (, line 202
		// call R2, line 202
		if !r_R2(env, context) {
			env.LimitBackward = v_4
			return false
		}
		// or, line 202
	lab1:
		for {
			var v_5 = env.Limit - env.Cursor
		lab2:
			for {
				// literal, line 202
				if !env.EqSB("s") {
					break lab2
				}
				break lab1
			}
			env.Cursor = env.Limit - v_5
			// literal, line 202
			if !env.EqSB("t") {
				env.LimitBackward = v_4
				return false
			}
			break lab1
		}
		// delete, line 202
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 204
		// <-, line 204
		if !env.SliceFrom("i") {
			return false
		}
	} else if among_var == 3 {
		// (, line 205
		// delete, line 205
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 4 {
		// (, line 206
		// literal, line 206
		if !env.EqSB("gu") {
			env.LimitBackward = v_4
			return false
		}
		// delete, line 206
		if !env.SliceDel() {
			return false
		}
	}
	env.LimitBackward = v_4
	return true
}

func r_un_double(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 211
	// test, line 212
	var v_1 = env.Limit - env.Cursor
	// among, line 212
	if env.FindAmongB(A_8, context) == 0 {
		return false
	}
	env.Cursor = env.Limit - v_1
	// [, line 212
	env.Ket = env.Cursor
	// next, line 212
	if env.Cursor <= env.LimitBackward {
		return false
	}
	env.PrevChar()
	// ], line 212
	env.Bra = env.Cursor
	// delete, line 212
	if !env.SliceDel() {
		return false
	}
	return true
}

func r_un_accent(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 215
	// atleast, line 216
	var v_1 = 1
	// atleast, line 216
replab0:
	for {
	lab1:
		for range [2]struct{}{} {
			if !env.OutGroupingB(G_v, 97, 251) {
				break lab1
			}
			v_1--
			continue replab0
		}
		break replab0
	}
	if v_1 > 0 {
		return false
	}
	// [, line 217
	env.Ket = env.Cursor
	// or, line 217
lab2:
	for {
		var v_3 = env.Limit - env.Cursor
	lab3:
		for {
			// literal, line 217
			if !env.EqSB("\u00E9") {
				break lab3
			}
			break lab2
		}
		env.Cursor = env.Limit - v_3
		// literal, line 217
		if !env.EqSB("\u00E8") {
			return false
		}
		break lab2
	}
	// ], line 217
	env.Bra = env.Cursor
	// <-, line 217
	if !env.SliceFrom("e") {
		return false
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	// (, line 221
	// do, line 223
	var v_1 = env.Cursor
lab0:
	for {
		// call prelude, line 223
		if !r_prelude(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// do, line 224
	var v_2 = env.Cursor
lab1:
	for {
		// call mark_regions, line 224
		if !r_mark_regions(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = v_2
	// backwards, line 225
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 225
	// do, line 227
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// (, line 227
		// or, line 237
	lab3:
		for {
			var v_4 = env.Limit - env.Cursor
		lab4:
			for {
				// (, line 228
				// and, line 233
				var v_5 = env.Limit - env.Cursor
				// (, line 229
				// or, line 229
			lab5:
				for {
					var v_6 = env.Limit - env.Cursor
				lab6:
					for {
						// call standard_suffix, line 229
						if !r_standard_suffix(env, context) {
							break lab6
						}
						break lab5
					}
					env.Cursor = env.Limit - v_6
				lab7:
					for {
						// call i_verb_suffix, line 230
						if !r_i_verb_suffix(env, context) {
							break lab7
						}
						break lab5
					}
					env.Cursor = env.Limit - v_6
					// call verb_suffix, line 231
					if !r_verb_suffix(env, context) {
						break lab4
					}
					break lab5
				}
				env.Cursor = env.Limit - v_5
				// try, line 234
				var v_7 = env.Limit - env.Cursor
			lab8:
				for {
					// (, line 234
					// [, line 234
					env.Ket = env.Cursor
					// or, line 234
				lab9:
					for {
						var v_8 = env.Limit - env.Cursor
					lab10:
						for {
							// (, line 234
							// literal, line 234
							if !env.EqSB("Y") {
								break lab10
							}
							// ], line 234
							env.Bra = env.Cursor
							// <-, line 234
							if !env.SliceFrom("i") {
								return false
							}
							break lab9
						}
						env.Cursor = env.Limit - v_8
						// (, line 235
						// literal, line 235
						if !env.EqSB("\u00E7") {
							env.Cursor = env.Limit - v_7
							break lab8
						}
						// ], line 235
						env.Bra = env.Cursor
						// <-, line 235
						if !env.SliceFrom("c") {
							return false
						}
						break lab9
					}
					break lab8
				}
				break lab3
			}
			env.Cursor = env.Limit - v_4
			// call residual_suffix, line 238
			if !r_residual_suffix(env, context) {
				break lab2
			}
			break lab3
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 243
	var v_9 = env.Limit - env.Cursor
lab11:
	for {
		// call un_double, line 243
		if !r_un_double(env, context) {
			break lab11
		}
		break lab11
	}
	env.Cursor = env.Limit - v_9
	// do, line 244
	var v_10 = env.Limit - env.Cursor
lab12:
	for {
		// call un_accent, line 244
		if !r_un_accent(env, context) {
			break lab12
		}
		break lab12
	}
	env.Cursor = env.Limit - v_10
	env.Cursor = env.LimitBackward
	// do, line 246
	var v_11 = env.Cursor
lab13:
	for {
		// call postlude, line 246
		if !r_postlude(env, context) {
			break lab13
		}
		break lab13
	}
	env.Cursor = v_11
	return true
}
