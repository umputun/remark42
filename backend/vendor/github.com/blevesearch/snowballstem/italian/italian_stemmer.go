//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package italian

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 7, F: nil},
	{Str: "qu", A: 0, B: 6, F: nil},
	{Str: "\u00E1", A: 0, B: 1, F: nil},
	{Str: "\u00E9", A: 0, B: 2, F: nil},
	{Str: "\u00ED", A: 0, B: 3, F: nil},
	{Str: "\u00F3", A: 0, B: 4, F: nil},
	{Str: "\u00FA", A: 0, B: 5, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "I", A: 0, B: 1, F: nil},
	{Str: "U", A: 0, B: 2, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "la", A: -1, B: -1, F: nil},
	{Str: "cela", A: 0, B: -1, F: nil},
	{Str: "gliela", A: 0, B: -1, F: nil},
	{Str: "mela", A: 0, B: -1, F: nil},
	{Str: "tela", A: 0, B: -1, F: nil},
	{Str: "vela", A: 0, B: -1, F: nil},
	{Str: "le", A: -1, B: -1, F: nil},
	{Str: "cele", A: 6, B: -1, F: nil},
	{Str: "gliele", A: 6, B: -1, F: nil},
	{Str: "mele", A: 6, B: -1, F: nil},
	{Str: "tele", A: 6, B: -1, F: nil},
	{Str: "vele", A: 6, B: -1, F: nil},
	{Str: "ne", A: -1, B: -1, F: nil},
	{Str: "cene", A: 12, B: -1, F: nil},
	{Str: "gliene", A: 12, B: -1, F: nil},
	{Str: "mene", A: 12, B: -1, F: nil},
	{Str: "sene", A: 12, B: -1, F: nil},
	{Str: "tene", A: 12, B: -1, F: nil},
	{Str: "vene", A: 12, B: -1, F: nil},
	{Str: "ci", A: -1, B: -1, F: nil},
	{Str: "li", A: -1, B: -1, F: nil},
	{Str: "celi", A: 20, B: -1, F: nil},
	{Str: "glieli", A: 20, B: -1, F: nil},
	{Str: "meli", A: 20, B: -1, F: nil},
	{Str: "teli", A: 20, B: -1, F: nil},
	{Str: "veli", A: 20, B: -1, F: nil},
	{Str: "gli", A: 20, B: -1, F: nil},
	{Str: "mi", A: -1, B: -1, F: nil},
	{Str: "si", A: -1, B: -1, F: nil},
	{Str: "ti", A: -1, B: -1, F: nil},
	{Str: "vi", A: -1, B: -1, F: nil},
	{Str: "lo", A: -1, B: -1, F: nil},
	{Str: "celo", A: 31, B: -1, F: nil},
	{Str: "glielo", A: 31, B: -1, F: nil},
	{Str: "melo", A: 31, B: -1, F: nil},
	{Str: "telo", A: 31, B: -1, F: nil},
	{Str: "velo", A: 31, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ando", A: -1, B: 1, F: nil},
	{Str: "endo", A: -1, B: 1, F: nil},
	{Str: "ar", A: -1, B: 2, F: nil},
	{Str: "er", A: -1, B: 2, F: nil},
	{Str: "ir", A: -1, B: 2, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: -1, F: nil},
	{Str: "abil", A: -1, B: -1, F: nil},
	{Str: "os", A: -1, B: -1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "ica", A: -1, B: 1, F: nil},
	{Str: "logia", A: -1, B: 3, F: nil},
	{Str: "osa", A: -1, B: 1, F: nil},
	{Str: "ista", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 9, F: nil},
	{Str: "anza", A: -1, B: 1, F: nil},
	{Str: "enza", A: -1, B: 5, F: nil},
	{Str: "ice", A: -1, B: 1, F: nil},
	{Str: "atrice", A: 7, B: 1, F: nil},
	{Str: "iche", A: -1, B: 1, F: nil},
	{Str: "logie", A: -1, B: 3, F: nil},
	{Str: "abile", A: -1, B: 1, F: nil},
	{Str: "ibile", A: -1, B: 1, F: nil},
	{Str: "usione", A: -1, B: 4, F: nil},
	{Str: "azione", A: -1, B: 2, F: nil},
	{Str: "uzione", A: -1, B: 4, F: nil},
	{Str: "atore", A: -1, B: 2, F: nil},
	{Str: "ose", A: -1, B: 1, F: nil},
	{Str: "ante", A: -1, B: 1, F: nil},
	{Str: "mente", A: -1, B: 1, F: nil},
	{Str: "amente", A: 19, B: 7, F: nil},
	{Str: "iste", A: -1, B: 1, F: nil},
	{Str: "ive", A: -1, B: 9, F: nil},
	{Str: "anze", A: -1, B: 1, F: nil},
	{Str: "enze", A: -1, B: 5, F: nil},
	{Str: "ici", A: -1, B: 1, F: nil},
	{Str: "atrici", A: 25, B: 1, F: nil},
	{Str: "ichi", A: -1, B: 1, F: nil},
	{Str: "abili", A: -1, B: 1, F: nil},
	{Str: "ibili", A: -1, B: 1, F: nil},
	{Str: "ismi", A: -1, B: 1, F: nil},
	{Str: "usioni", A: -1, B: 4, F: nil},
	{Str: "azioni", A: -1, B: 2, F: nil},
	{Str: "uzioni", A: -1, B: 4, F: nil},
	{Str: "atori", A: -1, B: 2, F: nil},
	{Str: "osi", A: -1, B: 1, F: nil},
	{Str: "anti", A: -1, B: 1, F: nil},
	{Str: "amenti", A: -1, B: 6, F: nil},
	{Str: "imenti", A: -1, B: 6, F: nil},
	{Str: "isti", A: -1, B: 1, F: nil},
	{Str: "ivi", A: -1, B: 9, F: nil},
	{Str: "ico", A: -1, B: 1, F: nil},
	{Str: "ismo", A: -1, B: 1, F: nil},
	{Str: "oso", A: -1, B: 1, F: nil},
	{Str: "amento", A: -1, B: 6, F: nil},
	{Str: "imento", A: -1, B: 6, F: nil},
	{Str: "ivo", A: -1, B: 9, F: nil},
	{Str: "it\u00E0", A: -1, B: 8, F: nil},
	{Str: "ist\u00E0", A: -1, B: 1, F: nil},
	{Str: "ist\u00E8", A: -1, B: 1, F: nil},
	{Str: "ist\u00EC", A: -1, B: 1, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "isca", A: -1, B: 1, F: nil},
	{Str: "enda", A: -1, B: 1, F: nil},
	{Str: "ata", A: -1, B: 1, F: nil},
	{Str: "ita", A: -1, B: 1, F: nil},
	{Str: "uta", A: -1, B: 1, F: nil},
	{Str: "ava", A: -1, B: 1, F: nil},
	{Str: "eva", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 1, F: nil},
	{Str: "erebbe", A: -1, B: 1, F: nil},
	{Str: "irebbe", A: -1, B: 1, F: nil},
	{Str: "isce", A: -1, B: 1, F: nil},
	{Str: "ende", A: -1, B: 1, F: nil},
	{Str: "are", A: -1, B: 1, F: nil},
	{Str: "ere", A: -1, B: 1, F: nil},
	{Str: "ire", A: -1, B: 1, F: nil},
	{Str: "asse", A: -1, B: 1, F: nil},
	{Str: "ate", A: -1, B: 1, F: nil},
	{Str: "avate", A: 16, B: 1, F: nil},
	{Str: "evate", A: 16, B: 1, F: nil},
	{Str: "ivate", A: 16, B: 1, F: nil},
	{Str: "ete", A: -1, B: 1, F: nil},
	{Str: "erete", A: 20, B: 1, F: nil},
	{Str: "irete", A: 20, B: 1, F: nil},
	{Str: "ite", A: -1, B: 1, F: nil},
	{Str: "ereste", A: -1, B: 1, F: nil},
	{Str: "ireste", A: -1, B: 1, F: nil},
	{Str: "ute", A: -1, B: 1, F: nil},
	{Str: "erai", A: -1, B: 1, F: nil},
	{Str: "irai", A: -1, B: 1, F: nil},
	{Str: "isci", A: -1, B: 1, F: nil},
	{Str: "endi", A: -1, B: 1, F: nil},
	{Str: "erei", A: -1, B: 1, F: nil},
	{Str: "irei", A: -1, B: 1, F: nil},
	{Str: "assi", A: -1, B: 1, F: nil},
	{Str: "ati", A: -1, B: 1, F: nil},
	{Str: "iti", A: -1, B: 1, F: nil},
	{Str: "eresti", A: -1, B: 1, F: nil},
	{Str: "iresti", A: -1, B: 1, F: nil},
	{Str: "uti", A: -1, B: 1, F: nil},
	{Str: "avi", A: -1, B: 1, F: nil},
	{Str: "evi", A: -1, B: 1, F: nil},
	{Str: "ivi", A: -1, B: 1, F: nil},
	{Str: "isco", A: -1, B: 1, F: nil},
	{Str: "ando", A: -1, B: 1, F: nil},
	{Str: "endo", A: -1, B: 1, F: nil},
	{Str: "Yamo", A: -1, B: 1, F: nil},
	{Str: "iamo", A: -1, B: 1, F: nil},
	{Str: "avamo", A: -1, B: 1, F: nil},
	{Str: "evamo", A: -1, B: 1, F: nil},
	{Str: "ivamo", A: -1, B: 1, F: nil},
	{Str: "eremo", A: -1, B: 1, F: nil},
	{Str: "iremo", A: -1, B: 1, F: nil},
	{Str: "assimo", A: -1, B: 1, F: nil},
	{Str: "ammo", A: -1, B: 1, F: nil},
	{Str: "emmo", A: -1, B: 1, F: nil},
	{Str: "eremmo", A: 54, B: 1, F: nil},
	{Str: "iremmo", A: 54, B: 1, F: nil},
	{Str: "immo", A: -1, B: 1, F: nil},
	{Str: "ano", A: -1, B: 1, F: nil},
	{Str: "iscano", A: 58, B: 1, F: nil},
	{Str: "avano", A: 58, B: 1, F: nil},
	{Str: "evano", A: 58, B: 1, F: nil},
	{Str: "ivano", A: 58, B: 1, F: nil},
	{Str: "eranno", A: -1, B: 1, F: nil},
	{Str: "iranno", A: -1, B: 1, F: nil},
	{Str: "ono", A: -1, B: 1, F: nil},
	{Str: "iscono", A: 65, B: 1, F: nil},
	{Str: "arono", A: 65, B: 1, F: nil},
	{Str: "erono", A: 65, B: 1, F: nil},
	{Str: "irono", A: 65, B: 1, F: nil},
	{Str: "erebbero", A: -1, B: 1, F: nil},
	{Str: "irebbero", A: -1, B: 1, F: nil},
	{Str: "assero", A: -1, B: 1, F: nil},
	{Str: "essero", A: -1, B: 1, F: nil},
	{Str: "issero", A: -1, B: 1, F: nil},
	{Str: "ato", A: -1, B: 1, F: nil},
	{Str: "ito", A: -1, B: 1, F: nil},
	{Str: "uto", A: -1, B: 1, F: nil},
	{Str: "avo", A: -1, B: 1, F: nil},
	{Str: "evo", A: -1, B: 1, F: nil},
	{Str: "ivo", A: -1, B: 1, F: nil},
	{Str: "ar", A: -1, B: 1, F: nil},
	{Str: "ir", A: -1, B: 1, F: nil},
	{Str: "er\u00E0", A: -1, B: 1, F: nil},
	{Str: "ir\u00E0", A: -1, B: 1, F: nil},
	{Str: "er\u00F2", A: -1, B: 1, F: nil},
	{Str: "ir\u00F2", A: -1, B: 1, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2, 1}

var G_AEIO = []byte{17, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2}

var G_CG = []byte{17}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 34
	// test, line 35
	var v_1 = env.Cursor
	// repeat, line 35
replab0:
	for {
		var v_2 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 35
			// [, line 36
			env.Bra = env.Cursor
			// substring, line 36
			among_var = env.FindAmong(A_0, context)
			if among_var == 0 {
				break lab1
			}
			// ], line 36
			env.Ket = env.Cursor
			if among_var == 0 {
				break lab1
			} else if among_var == 1 {
				// (, line 37
				// <-, line 37
				if !env.SliceFrom("\u00E0") {
					return false
				}
			} else if among_var == 2 {
				// (, line 38
				// <-, line 38
				if !env.SliceFrom("\u00E8") {
					return false
				}
			} else if among_var == 3 {
				// (, line 39
				// <-, line 39
				if !env.SliceFrom("\u00EC") {
					return false
				}
			} else if among_var == 4 {
				// (, line 40
				// <-, line 40
				if !env.SliceFrom("\u00F2") {
					return false
				}
			} else if among_var == 5 {
				// (, line 41
				// <-, line 41
				if !env.SliceFrom("\u00F9") {
					return false
				}
			} else if among_var == 6 {
				// (, line 42
				// <-, line 42
				if !env.SliceFrom("qU") {
					return false
				}
			} else if among_var == 7 {
				// (, line 43
				// next, line 43
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_2
		break replab0
	}
	env.Cursor = v_1
	// repeat, line 46
replab2:
	for {
		var v_3 = env.Cursor
	lab3:
		for range [2]struct{}{} {
			// goto, line 46
		golab4:
			for {
				var v_4 = env.Cursor
			lab5:
				for {
					// (, line 46
					if !env.InGrouping(G_v, 97, 249) {
						break lab5
					}
					// [, line 47
					env.Bra = env.Cursor
					// or, line 47
				lab6:
					for {
						var v_5 = env.Cursor
					lab7:
						for {
							// (, line 47
							// literal, line 47
							if !env.EqS("u") {
								break lab7
							}
							// ], line 47
							env.Ket = env.Cursor
							if !env.InGrouping(G_v, 97, 249) {
								break lab7
							}
							// <-, line 47
							if !env.SliceFrom("U") {
								return false
							}
							break lab6
						}
						env.Cursor = v_5
						// (, line 48
						// literal, line 48
						if !env.EqS("i") {
							break lab5
						}
						// ], line 48
						env.Ket = env.Cursor
						if !env.InGrouping(G_v, 97, 249) {
							break lab5
						}
						// <-, line 48
						if !env.SliceFrom("I") {
							return false
						}
						break lab6
					}
					env.Cursor = v_4
					break golab4
				}
				env.Cursor = v_4
				if env.Cursor >= env.Limit {
					break lab3
				}
				env.NextChar()
			}
			continue replab2
		}
		env.Cursor = v_3
		break replab2
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 52
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 58
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 58
		// or, line 60
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				// (, line 59
				if !env.InGrouping(G_v, 97, 249) {
					break lab2
				}
				// or, line 59
			lab3:
				for {
					var v_3 = env.Cursor
				lab4:
					for {
						// (, line 59
						if !env.OutGrouping(G_v, 97, 249) {
							break lab4
						}
						// gopast, line 59
					golab5:
						for {
						lab6:
							for {
								if !env.InGrouping(G_v, 97, 249) {
									break lab6
								}
								break golab5
							}
							if env.Cursor >= env.Limit {
								break lab4
							}
							env.NextChar()
						}
						break lab3
					}
					env.Cursor = v_3
					// (, line 59
					if !env.InGrouping(G_v, 97, 249) {
						break lab2
					}
					// gopast, line 59
				golab7:
					for {
					lab8:
						for {
							if !env.OutGrouping(G_v, 97, 249) {
								break lab8
							}
							break golab7
						}
						if env.Cursor >= env.Limit {
							break lab2
						}
						env.NextChar()
					}
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			// (, line 61
			if !env.OutGrouping(G_v, 97, 249) {
				break lab0
			}
			// or, line 61
		lab9:
			for {
				var v_6 = env.Cursor
			lab10:
				for {
					// (, line 61
					if !env.OutGrouping(G_v, 97, 249) {
						break lab10
					}
					// gopast, line 61
				golab11:
					for {
					lab12:
						for {
							if !env.InGrouping(G_v, 97, 249) {
								break lab12
							}
							break golab11
						}
						if env.Cursor >= env.Limit {
							break lab10
						}
						env.NextChar()
					}
					break lab9
				}
				env.Cursor = v_6
				// (, line 61
				if !env.InGrouping(G_v, 97, 249) {
					break lab0
				}
				// next, line 61
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
				break lab9
			}
			break lab1
		}
		// setmark pV, line 62
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	// do, line 64
	var v_8 = env.Cursor
lab13:
	for {
		// (, line 64
		// gopast, line 65
	golab14:
		for {
		lab15:
			for {
				if !env.InGrouping(G_v, 97, 249) {
					break lab15
				}
				break golab14
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 65
	golab16:
		for {
		lab17:
			for {
				if !env.OutGrouping(G_v, 97, 249) {
					break lab17
				}
				break golab16
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p1, line 65
		context.i_p1 = env.Cursor
		// gopast, line 66
	golab18:
		for {
		lab19:
			for {
				if !env.InGrouping(G_v, 97, 249) {
					break lab19
				}
				break golab18
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 66
	golab20:
		for {
		lab21:
			for {
				if !env.OutGrouping(G_v, 97, 249) {
					break lab21
				}
				break golab20
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p2, line 66
		context.i_p2 = env.Cursor
		break lab13
	}
	env.Cursor = v_8
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// repeat, line 70
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 70
			// [, line 72
			env.Bra = env.Cursor
			// substring, line 72
			among_var = env.FindAmong(A_1, context)
			if among_var == 0 {
				break lab1
			}
			// ], line 72
			env.Ket = env.Cursor
			if among_var == 0 {
				break lab1
			} else if among_var == 1 {
				// (, line 73
				// <-, line 73
				if !env.SliceFrom("i") {
					return false
				}
			} else if among_var == 2 {
				// (, line 74
				// <-, line 74
				if !env.SliceFrom("u") {
					return false
				}
			} else if among_var == 3 {
				// (, line 75
				// next, line 75
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_attached_pronoun(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 86
	// [, line 87
	env.Ket = env.Cursor
	// substring, line 87
	if env.FindAmongB(A_2, context) == 0 {
		return false
	}
	// ], line 87
	env.Bra = env.Cursor
	// among, line 97
	among_var = env.FindAmongB(A_3, context)
	if among_var == 0 {
		return false
	}
	// (, line 97
	// call RV, line 97
	if !r_RV(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 98
		// delete, line 98
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 99
		// <-, line 99
		if !env.SliceFrom("e") {
			return false
		}
	}
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 103
	// [, line 104
	env.Ket = env.Cursor
	// substring, line 104
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		return false
	}
	// ], line 104
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 111
		// call R2, line 111
		if !r_R2(env, context) {
			return false
		}
		// delete, line 111
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 113
		// call R2, line 113
		if !r_R2(env, context) {
			return false
		}
		// delete, line 113
		if !env.SliceDel() {
			return false
		}
		// try, line 114
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 114
			// [, line 114
			env.Ket = env.Cursor
			// literal, line 114
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// ], line 114
			env.Bra = env.Cursor
			// call R2, line 114
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// delete, line 114
			if !env.SliceDel() {
				return false
			}
			break lab0
		}
	} else if among_var == 3 {
		// (, line 117
		// call R2, line 117
		if !r_R2(env, context) {
			return false
		}
		// <-, line 117
		if !env.SliceFrom("log") {
			return false
		}
	} else if among_var == 4 {
		// (, line 119
		// call R2, line 119
		if !r_R2(env, context) {
			return false
		}
		// <-, line 119
		if !env.SliceFrom("u") {
			return false
		}
	} else if among_var == 5 {
		// (, line 121
		// call R2, line 121
		if !r_R2(env, context) {
			return false
		}
		// <-, line 121
		if !env.SliceFrom("ente") {
			return false
		}
	} else if among_var == 6 {
		// (, line 123
		// call RV, line 123
		if !r_RV(env, context) {
			return false
		}
		// delete, line 123
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 7 {
		// (, line 124
		// call R1, line 125
		if !r_R1(env, context) {
			return false
		}
		// delete, line 125
		if !env.SliceDel() {
			return false
		}
		// try, line 126
		var v_2 = env.Limit - env.Cursor
	lab1:
		for {
			// (, line 126
			// [, line 127
			env.Ket = env.Cursor
			// substring, line 127
			among_var = env.FindAmongB(A_4, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			// ], line 127
			env.Bra = env.Cursor
			// call R2, line 127
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			// delete, line 127
			if !env.SliceDel() {
				return false
			}
			if among_var == 0 {
				env.Cursor = env.Limit - v_2
				break lab1
			} else if among_var == 1 {
				// (, line 128
				// [, line 128
				env.Ket = env.Cursor
				// literal, line 128
				if !env.EqSB("at") {
					env.Cursor = env.Limit - v_2
					break lab1
				}
				// ], line 128
				env.Bra = env.Cursor
				// call R2, line 128
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_2
					break lab1
				}
				// delete, line 128
				if !env.SliceDel() {
					return false
				}
			}
			break lab1
		}
	} else if among_var == 8 {
		// (, line 133
		// call R2, line 134
		if !r_R2(env, context) {
			return false
		}
		// delete, line 134
		if !env.SliceDel() {
			return false
		}
		// try, line 135
		var v_3 = env.Limit - env.Cursor
	lab2:
		for {
			// (, line 135
			// [, line 136
			env.Ket = env.Cursor
			// substring, line 136
			among_var = env.FindAmongB(A_5, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab2
			}
			// ], line 136
			env.Bra = env.Cursor
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab2
			} else if among_var == 1 {
				// (, line 137
				// call R2, line 137
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab2
				}
				// delete, line 137
				if !env.SliceDel() {
					return false
				}
			}
			break lab2
		}
	} else if among_var == 9 {
		// (, line 141
		// call R2, line 142
		if !r_R2(env, context) {
			return false
		}
		// delete, line 142
		if !env.SliceDel() {
			return false
		}
		// try, line 143
		var v_4 = env.Limit - env.Cursor
	lab3:
		for {
			// (, line 143
			// [, line 143
			env.Ket = env.Cursor
			// literal, line 143
			if !env.EqSB("at") {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			// ], line 143
			env.Bra = env.Cursor
			// call R2, line 143
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			// delete, line 143
			if !env.SliceDel() {
				return false
			}
			// [, line 143
			env.Ket = env.Cursor
			// literal, line 143
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			// ], line 143
			env.Bra = env.Cursor
			// call R2, line 143
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			// delete, line 143
			if !env.SliceDel() {
				return false
			}
			break lab3
		}
	}
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// setlimit, line 148
	var v_1 = env.Limit - env.Cursor
	// tomark, line 148
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 148
	// [, line 149
	env.Ket = env.Cursor
	// substring, line 149
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 149
	env.Bra = env.Cursor
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	} else if among_var == 1 {
		// (, line 163
		// delete, line 163
		if !env.SliceDel() {
			return false
		}
	}
	env.LimitBackward = v_2
	return true
}

func r_vowel_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 170
	// try, line 171
	var v_1 = env.Limit - env.Cursor
lab0:
	for {
		// (, line 171
		// [, line 172
		env.Ket = env.Cursor
		if !env.InGroupingB(G_AEIO, 97, 242) {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// ], line 172
		env.Bra = env.Cursor
		// call RV, line 172
		if !r_RV(env, context) {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// delete, line 172
		if !env.SliceDel() {
			return false
		}
		// [, line 173
		env.Ket = env.Cursor
		// literal, line 173
		if !env.EqSB("i") {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// ], line 173
		env.Bra = env.Cursor
		// call RV, line 173
		if !r_RV(env, context) {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// delete, line 173
		if !env.SliceDel() {
			return false
		}
		break lab0
	}
	// try, line 175
	var v_2 = env.Limit - env.Cursor
lab1:
	for {
		// (, line 175
		// [, line 176
		env.Ket = env.Cursor
		// literal, line 176
		if !env.EqSB("h") {
			env.Cursor = env.Limit - v_2
			break lab1
		}
		// ], line 176
		env.Bra = env.Cursor
		if !env.InGroupingB(G_CG, 99, 103) {
			env.Cursor = env.Limit - v_2
			break lab1
		}
		// call RV, line 176
		if !r_RV(env, context) {
			env.Cursor = env.Limit - v_2
			break lab1
		}
		// delete, line 176
		if !env.SliceDel() {
			return false
		}
		break lab1
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	// (, line 181
	// do, line 182
	var v_1 = env.Cursor
lab0:
	for {
		// call prelude, line 182
		if !r_prelude(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// do, line 183
	var v_2 = env.Cursor
lab1:
	for {
		// call mark_regions, line 183
		if !r_mark_regions(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = v_2
	// backwards, line 184
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 184
	// do, line 185
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// call attached_pronoun, line 185
		if !r_attached_pronoun(env, context) {
			break lab2
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 186
	var v_4 = env.Limit - env.Cursor
lab3:
	for {
		// (, line 186
		// or, line 186
	lab4:
		for {
			var v_5 = env.Limit - env.Cursor
		lab5:
			for {
				// call standard_suffix, line 186
				if !r_standard_suffix(env, context) {
					break lab5
				}
				break lab4
			}
			env.Cursor = env.Limit - v_5
			// call verb_suffix, line 186
			if !r_verb_suffix(env, context) {
				break lab3
			}
			break lab4
		}
		break lab3
	}
	env.Cursor = env.Limit - v_4
	// do, line 187
	var v_6 = env.Limit - env.Cursor
lab6:
	for {
		// call vowel_suffix, line 187
		if !r_vowel_suffix(env, context) {
			break lab6
		}
		break lab6
	}
	env.Cursor = env.Limit - v_6
	env.Cursor = env.LimitBackward
	// do, line 189
	var v_7 = env.Cursor
lab7:
	for {
		// call postlude, line 189
		if !r_postlude(env, context) {
			break lab7
		}
		break lab7
	}
	env.Cursor = v_7
	return true
}
