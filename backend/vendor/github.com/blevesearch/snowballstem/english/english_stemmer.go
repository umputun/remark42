//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package english

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "arsen", A: -1, B: -1, F: nil},
	{Str: "commun", A: -1, B: -1, F: nil},
	{Str: "gener", A: -1, B: -1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "'", A: -1, B: 1, F: nil},
	{Str: "'s'", A: 0, B: 1, F: nil},
	{Str: "'s", A: -1, B: 1, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "ied", A: -1, B: 2, F: nil},
	{Str: "s", A: -1, B: 3, F: nil},
	{Str: "ies", A: 1, B: 2, F: nil},
	{Str: "sses", A: 1, B: 1, F: nil},
	{Str: "ss", A: 1, B: -1, F: nil},
	{Str: "us", A: 1, B: -1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 3, F: nil},
	{Str: "bb", A: 0, B: 2, F: nil},
	{Str: "dd", A: 0, B: 2, F: nil},
	{Str: "ff", A: 0, B: 2, F: nil},
	{Str: "gg", A: 0, B: 2, F: nil},
	{Str: "bl", A: 0, B: 1, F: nil},
	{Str: "mm", A: 0, B: 2, F: nil},
	{Str: "nn", A: 0, B: 2, F: nil},
	{Str: "pp", A: 0, B: 2, F: nil},
	{Str: "rr", A: 0, B: 2, F: nil},
	{Str: "at", A: 0, B: 1, F: nil},
	{Str: "tt", A: 0, B: 2, F: nil},
	{Str: "iz", A: 0, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "ed", A: -1, B: 2, F: nil},
	{Str: "eed", A: 0, B: 1, F: nil},
	{Str: "ing", A: -1, B: 2, F: nil},
	{Str: "edly", A: -1, B: 2, F: nil},
	{Str: "eedly", A: 3, B: 1, F: nil},
	{Str: "ingly", A: -1, B: 2, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "anci", A: -1, B: 3, F: nil},
	{Str: "enci", A: -1, B: 2, F: nil},
	{Str: "ogi", A: -1, B: 13, F: nil},
	{Str: "li", A: -1, B: 16, F: nil},
	{Str: "bli", A: 3, B: 12, F: nil},
	{Str: "abli", A: 4, B: 4, F: nil},
	{Str: "alli", A: 3, B: 8, F: nil},
	{Str: "fulli", A: 3, B: 14, F: nil},
	{Str: "lessli", A: 3, B: 15, F: nil},
	{Str: "ousli", A: 3, B: 10, F: nil},
	{Str: "entli", A: 3, B: 5, F: nil},
	{Str: "aliti", A: -1, B: 8, F: nil},
	{Str: "biliti", A: -1, B: 12, F: nil},
	{Str: "iviti", A: -1, B: 11, F: nil},
	{Str: "tional", A: -1, B: 1, F: nil},
	{Str: "ational", A: 14, B: 7, F: nil},
	{Str: "alism", A: -1, B: 8, F: nil},
	{Str: "ation", A: -1, B: 7, F: nil},
	{Str: "ization", A: 17, B: 6, F: nil},
	{Str: "izer", A: -1, B: 6, F: nil},
	{Str: "ator", A: -1, B: 7, F: nil},
	{Str: "iveness", A: -1, B: 11, F: nil},
	{Str: "fulness", A: -1, B: 9, F: nil},
	{Str: "ousness", A: -1, B: 10, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "icate", A: -1, B: 4, F: nil},
	{Str: "ative", A: -1, B: 6, F: nil},
	{Str: "alize", A: -1, B: 3, F: nil},
	{Str: "iciti", A: -1, B: 4, F: nil},
	{Str: "ical", A: -1, B: 4, F: nil},
	{Str: "tional", A: -1, B: 1, F: nil},
	{Str: "ational", A: 5, B: 2, F: nil},
	{Str: "ful", A: -1, B: 5, F: nil},
	{Str: "ness", A: -1, B: 5, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "ance", A: -1, B: 1, F: nil},
	{Str: "ence", A: -1, B: 1, F: nil},
	{Str: "able", A: -1, B: 1, F: nil},
	{Str: "ible", A: -1, B: 1, F: nil},
	{Str: "ate", A: -1, B: 1, F: nil},
	{Str: "ive", A: -1, B: 1, F: nil},
	{Str: "ize", A: -1, B: 1, F: nil},
	{Str: "iti", A: -1, B: 1, F: nil},
	{Str: "al", A: -1, B: 1, F: nil},
	{Str: "ism", A: -1, B: 1, F: nil},
	{Str: "ion", A: -1, B: 2, F: nil},
	{Str: "er", A: -1, B: 1, F: nil},
	{Str: "ous", A: -1, B: 1, F: nil},
	{Str: "ant", A: -1, B: 1, F: nil},
	{Str: "ent", A: -1, B: 1, F: nil},
	{Str: "ment", A: 15, B: 1, F: nil},
	{Str: "ement", A: 16, B: 1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "e", A: -1, B: 1, F: nil},
	{Str: "l", A: -1, B: 2, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "succeed", A: -1, B: -1, F: nil},
	{Str: "proceed", A: -1, B: -1, F: nil},
	{Str: "exceed", A: -1, B: -1, F: nil},
	{Str: "canning", A: -1, B: -1, F: nil},
	{Str: "inning", A: -1, B: -1, F: nil},
	{Str: "earring", A: -1, B: -1, F: nil},
	{Str: "herring", A: -1, B: -1, F: nil},
	{Str: "outing", A: -1, B: -1, F: nil},
}

var A_10 = []*snowballRuntime.Among{
	{Str: "andes", A: -1, B: -1, F: nil},
	{Str: "atlas", A: -1, B: -1, F: nil},
	{Str: "bias", A: -1, B: -1, F: nil},
	{Str: "cosmos", A: -1, B: -1, F: nil},
	{Str: "dying", A: -1, B: 3, F: nil},
	{Str: "early", A: -1, B: 9, F: nil},
	{Str: "gently", A: -1, B: 7, F: nil},
	{Str: "howe", A: -1, B: -1, F: nil},
	{Str: "idly", A: -1, B: 6, F: nil},
	{Str: "lying", A: -1, B: 4, F: nil},
	{Str: "news", A: -1, B: -1, F: nil},
	{Str: "only", A: -1, B: 10, F: nil},
	{Str: "singly", A: -1, B: 11, F: nil},
	{Str: "skies", A: -1, B: 2, F: nil},
	{Str: "skis", A: -1, B: 1, F: nil},
	{Str: "sky", A: -1, B: -1, F: nil},
	{Str: "tying", A: -1, B: 5, F: nil},
	{Str: "ugly", A: -1, B: 8, F: nil},
}

var G_v = []byte{17, 65, 16, 1}

var G_v_WXY = []byte{1, 17, 65, 208, 1}

var G_valid_LI = []byte{55, 141, 2}

type Context struct {
	b_Y_found bool
	i_p2      int
	i_p1      int
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 25
	// unset Y_found, line 26
	context.b_Y_found = false
	// do, line 27
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 27
		// [, line 27
		env.Bra = env.Cursor
		// literal, line 27
		if !env.EqS("'") {
			break lab0
		}
		// ], line 27
		env.Ket = env.Cursor
		// delete, line 27
		if !env.SliceDel() {
			return false
		}
		break lab0
	}
	env.Cursor = v_1
	// do, line 28
	var v_2 = env.Cursor
lab1:
	for {
		// (, line 28
		// [, line 28
		env.Bra = env.Cursor
		// literal, line 28
		if !env.EqS("y") {
			break lab1
		}
		// ], line 28
		env.Ket = env.Cursor
		// <-, line 28
		if !env.SliceFrom("Y") {
			return false
		}
		// set Y_found, line 28
		context.b_Y_found = true
		break lab1
	}
	env.Cursor = v_2
	// do, line 29
	var v_3 = env.Cursor
lab2:
	for {
		// repeat, line 29
	replab3:
		for {
			var v_4 = env.Cursor
		lab4:
			for range [2]struct{}{} {
				// (, line 29
				// goto, line 29
			golab5:
				for {
					var v_5 = env.Cursor
				lab6:
					for {
						// (, line 29
						if !env.InGrouping(G_v, 97, 121) {
							break lab6
						}
						// [, line 29
						env.Bra = env.Cursor
						// literal, line 29
						if !env.EqS("y") {
							break lab6
						}
						// ], line 29
						env.Ket = env.Cursor
						env.Cursor = v_5
						break golab5
					}
					env.Cursor = v_5
					if env.Cursor >= env.Limit {
						break lab4
					}
					env.NextChar()
				}
				// <-, line 29
				if !env.SliceFrom("Y") {
					return false
				}
				// set Y_found, line 29
				context.b_Y_found = true
				continue replab3
			}
			env.Cursor = v_4
			break replab3
		}
		break lab2
	}
	env.Cursor = v_3
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 32
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 35
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 35
		// or, line 41
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				// among, line 36
				if env.FindAmong(A_0, context) == 0 {
					break lab2
				}
				break lab1
			}
			env.Cursor = v_2
			// (, line 41
			// gopast, line 41
		golab3:
			for {
			lab4:
				for {
					if !env.InGrouping(G_v, 97, 121) {
						break lab4
					}
					break golab3
				}
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
			}
			// gopast, line 41
		golab5:
			for {
			lab6:
				for {
					if !env.OutGrouping(G_v, 97, 121) {
						break lab6
					}
					break golab5
				}
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
			}
			break lab1
		}
		// setmark p1, line 42
		context.i_p1 = env.Cursor
		// gopast, line 43
	golab7:
		for {
		lab8:
			for {
				if !env.InGrouping(G_v, 97, 121) {
					break lab8
				}
				break golab7
			}
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
		}
		// gopast, line 43
	golab9:
		for {
		lab10:
			for {
				if !env.OutGrouping(G_v, 97, 121) {
					break lab10
				}
				break golab9
			}
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
		}
		// setmark p2, line 43
		context.i_p2 = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	return true
}

func r_shortv(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 49
	// or, line 51
lab0:
	for {
		var v_1 = env.Limit - env.Cursor
	lab1:
		for {
			// (, line 50
			if !env.OutGroupingB(G_v_WXY, 89, 121) {
				break lab1
			}
			if !env.InGroupingB(G_v, 97, 121) {
				break lab1
			}
			if !env.OutGroupingB(G_v, 97, 121) {
				break lab1
			}
			break lab0
		}
		env.Cursor = env.Limit - v_1
		// (, line 52
		if !env.OutGroupingB(G_v, 97, 121) {
			return false
		}
		if !env.InGroupingB(G_v, 97, 121) {
			return false
		}
		// atlimit, line 52
		if env.Cursor > env.LimitBackward {
			return false
		}
		break lab0
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_Step_1a(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 58
	// try, line 59
	var v_1 = env.Limit - env.Cursor
lab0:
	for {
		// (, line 59
		// [, line 60
		env.Ket = env.Cursor
		// substring, line 60
		among_var = env.FindAmongB(A_1, context)
		if among_var == 0 {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		// ], line 60
		env.Bra = env.Cursor
		if among_var == 0 {
			env.Cursor = env.Limit - v_1
			break lab0
		} else if among_var == 1 {
			// (, line 62
			// delete, line 62
			if !env.SliceDel() {
				return false
			}
		}
		break lab0
	}
	// [, line 65
	env.Ket = env.Cursor
	// substring, line 65
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	// ], line 65
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 66
		// <-, line 66
		if !env.SliceFrom("ss") {
			return false
		}
	} else if among_var == 2 {
		// (, line 68
		// or, line 68
	lab1:
		for {
			var v_2 = env.Limit - env.Cursor
		lab2:
			for {
				// (, line 68
				{
					// hop, line 68
					var c = env.ByteIndexForHop(-(2))
					if int32(env.LimitBackward) > c || c > int32(env.Limit) {
						break lab2
					}
					env.Cursor = int(c)
				}
				// <-, line 68
				if !env.SliceFrom("i") {
					return false
				}
				break lab1
			}
			env.Cursor = env.Limit - v_2
			// <-, line 68
			if !env.SliceFrom("ie") {
				return false
			}
			break lab1
		}
	} else if among_var == 3 {
		// (, line 69
		// next, line 69
		if env.Cursor <= env.LimitBackward {
			return false
		}
		env.PrevChar()
		// gopast, line 69
	golab3:
		for {
		lab4:
			for {
				if !env.InGroupingB(G_v, 97, 121) {
					break lab4
				}
				break golab3
			}
			if env.Cursor <= env.LimitBackward {
				return false
			}
			env.PrevChar()
		}
		// delete, line 69
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_Step_1b(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 74
	// [, line 75
	env.Ket = env.Cursor
	// substring, line 75
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		return false
	}
	// ], line 75
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 77
		// call R1, line 77
		if !r_R1(env, context) {
			return false
		}
		// <-, line 77
		if !env.SliceFrom("ee") {
			return false
		}
	} else if among_var == 2 {
		// (, line 79
		// test, line 80
		var v_1 = env.Limit - env.Cursor
		// gopast, line 80
	golab0:
		for {
		lab1:
			for {
				if !env.InGroupingB(G_v, 97, 121) {
					break lab1
				}
				break golab0
			}
			if env.Cursor <= env.LimitBackward {
				return false
			}
			env.PrevChar()
		}
		env.Cursor = env.Limit - v_1
		// delete, line 80
		if !env.SliceDel() {
			return false
		}
		// test, line 81
		var v_3 = env.Limit - env.Cursor
		// substring, line 81
		among_var = env.FindAmongB(A_3, context)
		if among_var == 0 {
			return false
		}
		env.Cursor = env.Limit - v_3
		if among_var == 0 {
			return false
		} else if among_var == 1 {
			// (, line 83
			{
				// <+, line 83
				var c = env.Cursor
				bra, ket := env.Cursor, env.Cursor
				env.Insert(bra, ket, "e")
				env.Cursor = c
			}
		} else if among_var == 2 {
			// (, line 86
			// [, line 86
			env.Ket = env.Cursor
			// next, line 86
			if env.Cursor <= env.LimitBackward {
				return false
			}
			env.PrevChar()
			// ], line 86
			env.Bra = env.Cursor
			// delete, line 86
			if !env.SliceDel() {
				return false
			}
		} else if among_var == 3 {
			// (, line 87
			// atmark, line 87
			if env.Cursor != context.i_p1 {
				return false
			}
			// test, line 87
			var v_4 = env.Limit - env.Cursor
			// call shortv, line 87
			if !r_shortv(env, context) {
				return false
			}
			env.Cursor = env.Limit - v_4
			{
				// <+, line 87
				var c = env.Cursor
				bra, ket := env.Cursor, env.Cursor
				env.Insert(bra, ket, "e")
				env.Cursor = c
			}
		}
	}
	return true
}

func r_Step_1c(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 93
	// [, line 94
	env.Ket = env.Cursor
	// or, line 94
lab0:
	for {
		var v_1 = env.Limit - env.Cursor
	lab1:
		for {
			// literal, line 94
			if !env.EqSB("y") {
				break lab1
			}
			break lab0
		}
		env.Cursor = env.Limit - v_1
		// literal, line 94
		if !env.EqSB("Y") {
			return false
		}
		break lab0
	}
	// ], line 94
	env.Bra = env.Cursor
	if !env.OutGroupingB(G_v, 97, 121) {
		return false
	}
	// not, line 95
	var v_2 = env.Limit - env.Cursor
lab2:
	for {
		// atlimit, line 95
		if env.Cursor > env.LimitBackward {
			break lab2
		}
		return false
	}
	env.Cursor = env.Limit - v_2
	// <-, line 96
	if !env.SliceFrom("i") {
		return false
	}
	return true
}

func r_Step_2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 99
	// [, line 100
	env.Ket = env.Cursor
	// substring, line 100
	among_var = env.FindAmongB(A_5, context)
	if among_var == 0 {
		return false
	}
	// ], line 100
	env.Bra = env.Cursor
	// call R1, line 100
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 101
		// <-, line 101
		if !env.SliceFrom("tion") {
			return false
		}
	} else if among_var == 2 {
		// (, line 102
		// <-, line 102
		if !env.SliceFrom("ence") {
			return false
		}
	} else if among_var == 3 {
		// (, line 103
		// <-, line 103
		if !env.SliceFrom("ance") {
			return false
		}
	} else if among_var == 4 {
		// (, line 104
		// <-, line 104
		if !env.SliceFrom("able") {
			return false
		}
	} else if among_var == 5 {
		// (, line 105
		// <-, line 105
		if !env.SliceFrom("ent") {
			return false
		}
	} else if among_var == 6 {
		// (, line 107
		// <-, line 107
		if !env.SliceFrom("ize") {
			return false
		}
	} else if among_var == 7 {
		// (, line 109
		// <-, line 109
		if !env.SliceFrom("ate") {
			return false
		}
	} else if among_var == 8 {
		// (, line 111
		// <-, line 111
		if !env.SliceFrom("al") {
			return false
		}
	} else if among_var == 9 {
		// (, line 112
		// <-, line 112
		if !env.SliceFrom("ful") {
			return false
		}
	} else if among_var == 10 {
		// (, line 114
		// <-, line 114
		if !env.SliceFrom("ous") {
			return false
		}
	} else if among_var == 11 {
		// (, line 116
		// <-, line 116
		if !env.SliceFrom("ive") {
			return false
		}
	} else if among_var == 12 {
		// (, line 118
		// <-, line 118
		if !env.SliceFrom("ble") {
			return false
		}
	} else if among_var == 13 {
		// (, line 119
		// literal, line 119
		if !env.EqSB("l") {
			return false
		}
		// <-, line 119
		if !env.SliceFrom("og") {
			return false
		}
	} else if among_var == 14 {
		// (, line 120
		// <-, line 120
		if !env.SliceFrom("ful") {
			return false
		}
	} else if among_var == 15 {
		// (, line 121
		// <-, line 121
		if !env.SliceFrom("less") {
			return false
		}
	} else if among_var == 16 {
		// (, line 122
		if !env.InGroupingB(G_valid_LI, 99, 116) {
			return false
		}
		// delete, line 122
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_Step_3(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 126
	// [, line 127
	env.Ket = env.Cursor
	// substring, line 127
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		return false
	}
	// ], line 127
	env.Bra = env.Cursor
	// call R1, line 127
	if !r_R1(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 128
		// <-, line 128
		if !env.SliceFrom("tion") {
			return false
		}
	} else if among_var == 2 {
		// (, line 129
		// <-, line 129
		if !env.SliceFrom("ate") {
			return false
		}
	} else if among_var == 3 {
		// (, line 130
		// <-, line 130
		if !env.SliceFrom("al") {
			return false
		}
	} else if among_var == 4 {
		// (, line 132
		// <-, line 132
		if !env.SliceFrom("ic") {
			return false
		}
	} else if among_var == 5 {
		// (, line 134
		// delete, line 134
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 6 {
		// (, line 136
		// call R2, line 136
		if !r_R2(env, context) {
			return false
		}
		// delete, line 136
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_Step_4(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 140
	// [, line 141
	env.Ket = env.Cursor
	// substring, line 141
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		return false
	}
	// ], line 141
	env.Bra = env.Cursor
	// call R2, line 141
	if !r_R2(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 144
		// delete, line 144
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 145
		// or, line 145
	lab0:
		for {
			var v_1 = env.Limit - env.Cursor
		lab1:
			for {
				// literal, line 145
				if !env.EqSB("s") {
					break lab1
				}
				break lab0
			}
			env.Cursor = env.Limit - v_1
			// literal, line 145
			if !env.EqSB("t") {
				return false
			}
			break lab0
		}
		// delete, line 145
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_Step_5(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 149
	// [, line 150
	env.Ket = env.Cursor
	// substring, line 150
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		return false
	}
	// ], line 150
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 151
		// or, line 151
	lab0:
		for {
			var v_1 = env.Limit - env.Cursor
		lab1:
			for {
				// call R2, line 151
				if !r_R2(env, context) {
					break lab1
				}
				break lab0
			}
			env.Cursor = env.Limit - v_1
			// (, line 151
			// call R1, line 151
			if !r_R1(env, context) {
				return false
			}
			// not, line 151
			var v_2 = env.Limit - env.Cursor
		lab2:
			for {
				// call shortv, line 151
				if !r_shortv(env, context) {
					break lab2
				}
				return false
			}
			env.Cursor = env.Limit - v_2
			break lab0
		}
		// delete, line 151
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 152
		// call R2, line 152
		if !r_R2(env, context) {
			return false
		}
		// literal, line 152
		if !env.EqSB("l") {
			return false
		}
		// delete, line 152
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_exception2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 156
	// [, line 158
	env.Ket = env.Cursor
	// substring, line 158
	if env.FindAmongB(A_9, context) == 0 {
		return false
	}
	// ], line 158
	env.Bra = env.Cursor
	// atlimit, line 158
	if env.Cursor > env.LimitBackward {
		return false
	}
	return true
}

func r_exception1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 168
	// [, line 170
	env.Bra = env.Cursor
	// substring, line 170
	among_var = env.FindAmong(A_10, context)
	if among_var == 0 {
		return false
	}
	// ], line 170
	env.Ket = env.Cursor
	// atlimit, line 170
	if env.Cursor < env.Limit {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 174
		// <-, line 174
		if !env.SliceFrom("ski") {
			return false
		}
	} else if among_var == 2 {
		// (, line 175
		// <-, line 175
		if !env.SliceFrom("sky") {
			return false
		}
	} else if among_var == 3 {
		// (, line 176
		// <-, line 176
		if !env.SliceFrom("die") {
			return false
		}
	} else if among_var == 4 {
		// (, line 177
		// <-, line 177
		if !env.SliceFrom("lie") {
			return false
		}
	} else if among_var == 5 {
		// (, line 178
		// <-, line 178
		if !env.SliceFrom("tie") {
			return false
		}
	} else if among_var == 6 {
		// (, line 182
		// <-, line 182
		if !env.SliceFrom("idl") {
			return false
		}
	} else if among_var == 7 {
		// (, line 183
		// <-, line 183
		if !env.SliceFrom("gentl") {
			return false
		}
	} else if among_var == 8 {
		// (, line 184
		// <-, line 184
		if !env.SliceFrom("ugli") {
			return false
		}
	} else if among_var == 9 {
		// (, line 185
		// <-, line 185
		if !env.SliceFrom("earli") {
			return false
		}
	} else if among_var == 10 {
		// (, line 186
		// <-, line 186
		if !env.SliceFrom("onli") {
			return false
		}
	} else if among_var == 11 {
		// (, line 187
		// <-, line 187
		if !env.SliceFrom("singl") {
			return false
		}
	}
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 203
	// Boolean test Y_found, line 203
	if !context.b_Y_found {
		return false
	}
	// repeat, line 203
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 203
			// goto, line 203
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
					// (, line 203
					// [, line 203
					env.Bra = env.Cursor
					// literal, line 203
					if !env.EqS("Y") {
						break lab3
					}
					// ], line 203
					env.Ket = env.Cursor
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			// <-, line 203
			if !env.SliceFrom("y") {
				return false
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		b_Y_found: false,
		i_p2:      0,
		i_p1:      0,
	}
	_ = context
	// (, line 205
	// or, line 207
lab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			// call exception1, line 207
			if !r_exception1(env, context) {
				break lab1
			}
			break lab0
		}
		env.Cursor = v_1
	lab2:
		for {
			// not, line 208
			var v_2 = env.Cursor
		lab3:
			for {
				{
					// hop, line 208
					var c = env.ByteIndexForHop((3))
					if int32(0) > c || c > int32(env.Limit) {
						break lab3
					}
					env.Cursor = int(c)
				}
				break lab2
			}
			env.Cursor = v_2
			break lab0
		}
		env.Cursor = v_1
		// (, line 208
		// do, line 209
		var v_3 = env.Cursor
	lab4:
		for {
			// call prelude, line 209
			if !r_prelude(env, context) {
				break lab4
			}
			break lab4
		}
		env.Cursor = v_3
		// do, line 210
		var v_4 = env.Cursor
	lab5:
		for {
			// call mark_regions, line 210
			if !r_mark_regions(env, context) {
				break lab5
			}
			break lab5
		}
		env.Cursor = v_4
		// backwards, line 211
		env.LimitBackward = env.Cursor
		env.Cursor = env.Limit
		// (, line 211
		// do, line 213
		var v_5 = env.Limit - env.Cursor
	lab6:
		for {
			// call Step_1a, line 213
			if !r_Step_1a(env, context) {
				break lab6
			}
			break lab6
		}
		env.Cursor = env.Limit - v_5
		// or, line 215
	lab7:
		for {
			var v_6 = env.Limit - env.Cursor
		lab8:
			for {
				// call exception2, line 215
				if !r_exception2(env, context) {
					break lab8
				}
				break lab7
			}
			env.Cursor = env.Limit - v_6
			// (, line 215
			// do, line 217
			var v_7 = env.Limit - env.Cursor
		lab9:
			for {
				// call Step_1b, line 217
				if !r_Step_1b(env, context) {
					break lab9
				}
				break lab9
			}
			env.Cursor = env.Limit - v_7
			// do, line 218
			var v_8 = env.Limit - env.Cursor
		lab10:
			for {
				// call Step_1c, line 218
				if !r_Step_1c(env, context) {
					break lab10
				}
				break lab10
			}
			env.Cursor = env.Limit - v_8
			// do, line 220
			var v_9 = env.Limit - env.Cursor
		lab11:
			for {
				// call Step_2, line 220
				if !r_Step_2(env, context) {
					break lab11
				}
				break lab11
			}
			env.Cursor = env.Limit - v_9
			// do, line 221
			var v_10 = env.Limit - env.Cursor
		lab12:
			for {
				// call Step_3, line 221
				if !r_Step_3(env, context) {
					break lab12
				}
				break lab12
			}
			env.Cursor = env.Limit - v_10
			// do, line 222
			var v_11 = env.Limit - env.Cursor
		lab13:
			for {
				// call Step_4, line 222
				if !r_Step_4(env, context) {
					break lab13
				}
				break lab13
			}
			env.Cursor = env.Limit - v_11
			// do, line 224
			var v_12 = env.Limit - env.Cursor
		lab14:
			for {
				// call Step_5, line 224
				if !r_Step_5(env, context) {
					break lab14
				}
				break lab14
			}
			env.Cursor = env.Limit - v_12
			break lab7
		}
		env.Cursor = env.LimitBackward
		// do, line 227
		var v_13 = env.Cursor
	lab15:
		for {
			// call postlude, line 227
			if !r_postlude(env, context) {
				break lab15
			}
			break lab15
		}
		env.Cursor = v_13
		break lab0
	}
	return true
}
