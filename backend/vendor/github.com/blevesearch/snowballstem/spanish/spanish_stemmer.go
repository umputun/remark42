//! This file was generated automatically by the Snowball to Go compiler
//! http://snowballstem.org/

package spanish

import (
	snowballRuntime "github.com/blevesearch/snowballstem"
)

var A_0 = []*snowballRuntime.Among{
	{Str: "", A: -1, B: 6, F: nil},
	{Str: "\u00E1", A: 0, B: 1, F: nil},
	{Str: "\u00E9", A: 0, B: 2, F: nil},
	{Str: "\u00ED", A: 0, B: 3, F: nil},
	{Str: "\u00F3", A: 0, B: 4, F: nil},
	{Str: "\u00FA", A: 0, B: 5, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	{Str: "la", A: -1, B: -1, F: nil},
	{Str: "sela", A: 0, B: -1, F: nil},
	{Str: "le", A: -1, B: -1, F: nil},
	{Str: "me", A: -1, B: -1, F: nil},
	{Str: "se", A: -1, B: -1, F: nil},
	{Str: "lo", A: -1, B: -1, F: nil},
	{Str: "selo", A: 5, B: -1, F: nil},
	{Str: "las", A: -1, B: -1, F: nil},
	{Str: "selas", A: 7, B: -1, F: nil},
	{Str: "les", A: -1, B: -1, F: nil},
	{Str: "los", A: -1, B: -1, F: nil},
	{Str: "selos", A: 10, B: -1, F: nil},
	{Str: "nos", A: -1, B: -1, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	{Str: "ando", A: -1, B: 6, F: nil},
	{Str: "iendo", A: -1, B: 6, F: nil},
	{Str: "yendo", A: -1, B: 7, F: nil},
	{Str: "\u00E1ndo", A: -1, B: 2, F: nil},
	{Str: "i\u00E9ndo", A: -1, B: 1, F: nil},
	{Str: "ar", A: -1, B: 6, F: nil},
	{Str: "er", A: -1, B: 6, F: nil},
	{Str: "ir", A: -1, B: 6, F: nil},
	{Str: "\u00E1r", A: -1, B: 3, F: nil},
	{Str: "\u00E9r", A: -1, B: 4, F: nil},
	{Str: "\u00EDr", A: -1, B: 5, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: -1, F: nil},
	{Str: "ad", A: -1, B: -1, F: nil},
	{Str: "os", A: -1, B: -1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	{Str: "able", A: -1, B: 1, F: nil},
	{Str: "ible", A: -1, B: 1, F: nil},
	{Str: "ante", A: -1, B: 1, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	{Str: "ic", A: -1, B: 1, F: nil},
	{Str: "abil", A: -1, B: 1, F: nil},
	{Str: "iv", A: -1, B: 1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	{Str: "ica", A: -1, B: 1, F: nil},
	{Str: "ancia", A: -1, B: 2, F: nil},
	{Str: "encia", A: -1, B: 5, F: nil},
	{Str: "adora", A: -1, B: 2, F: nil},
	{Str: "osa", A: -1, B: 1, F: nil},
	{Str: "ista", A: -1, B: 1, F: nil},
	{Str: "iva", A: -1, B: 9, F: nil},
	{Str: "anza", A: -1, B: 1, F: nil},
	{Str: "log\u00EDa", A: -1, B: 3, F: nil},
	{Str: "idad", A: -1, B: 8, F: nil},
	{Str: "able", A: -1, B: 1, F: nil},
	{Str: "ible", A: -1, B: 1, F: nil},
	{Str: "ante", A: -1, B: 2, F: nil},
	{Str: "mente", A: -1, B: 7, F: nil},
	{Str: "amente", A: 13, B: 6, F: nil},
	{Str: "aci\u00F3n", A: -1, B: 2, F: nil},
	{Str: "uci\u00F3n", A: -1, B: 4, F: nil},
	{Str: "ico", A: -1, B: 1, F: nil},
	{Str: "ismo", A: -1, B: 1, F: nil},
	{Str: "oso", A: -1, B: 1, F: nil},
	{Str: "amiento", A: -1, B: 1, F: nil},
	{Str: "imiento", A: -1, B: 1, F: nil},
	{Str: "ivo", A: -1, B: 9, F: nil},
	{Str: "ador", A: -1, B: 2, F: nil},
	{Str: "icas", A: -1, B: 1, F: nil},
	{Str: "ancias", A: -1, B: 2, F: nil},
	{Str: "encias", A: -1, B: 5, F: nil},
	{Str: "adoras", A: -1, B: 2, F: nil},
	{Str: "osas", A: -1, B: 1, F: nil},
	{Str: "istas", A: -1, B: 1, F: nil},
	{Str: "ivas", A: -1, B: 9, F: nil},
	{Str: "anzas", A: -1, B: 1, F: nil},
	{Str: "log\u00EDas", A: -1, B: 3, F: nil},
	{Str: "idades", A: -1, B: 8, F: nil},
	{Str: "ables", A: -1, B: 1, F: nil},
	{Str: "ibles", A: -1, B: 1, F: nil},
	{Str: "aciones", A: -1, B: 2, F: nil},
	{Str: "uciones", A: -1, B: 4, F: nil},
	{Str: "adores", A: -1, B: 2, F: nil},
	{Str: "antes", A: -1, B: 2, F: nil},
	{Str: "icos", A: -1, B: 1, F: nil},
	{Str: "ismos", A: -1, B: 1, F: nil},
	{Str: "osos", A: -1, B: 1, F: nil},
	{Str: "amientos", A: -1, B: 1, F: nil},
	{Str: "imientos", A: -1, B: 1, F: nil},
	{Str: "ivos", A: -1, B: 9, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	{Str: "ya", A: -1, B: 1, F: nil},
	{Str: "ye", A: -1, B: 1, F: nil},
	{Str: "yan", A: -1, B: 1, F: nil},
	{Str: "yen", A: -1, B: 1, F: nil},
	{Str: "yeron", A: -1, B: 1, F: nil},
	{Str: "yendo", A: -1, B: 1, F: nil},
	{Str: "yo", A: -1, B: 1, F: nil},
	{Str: "yas", A: -1, B: 1, F: nil},
	{Str: "yes", A: -1, B: 1, F: nil},
	{Str: "yais", A: -1, B: 1, F: nil},
	{Str: "yamos", A: -1, B: 1, F: nil},
	{Str: "y\u00F3", A: -1, B: 1, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	{Str: "aba", A: -1, B: 2, F: nil},
	{Str: "ada", A: -1, B: 2, F: nil},
	{Str: "ida", A: -1, B: 2, F: nil},
	{Str: "ara", A: -1, B: 2, F: nil},
	{Str: "iera", A: -1, B: 2, F: nil},
	{Str: "\u00EDa", A: -1, B: 2, F: nil},
	{Str: "ar\u00EDa", A: 5, B: 2, F: nil},
	{Str: "er\u00EDa", A: 5, B: 2, F: nil},
	{Str: "ir\u00EDa", A: 5, B: 2, F: nil},
	{Str: "ad", A: -1, B: 2, F: nil},
	{Str: "ed", A: -1, B: 2, F: nil},
	{Str: "id", A: -1, B: 2, F: nil},
	{Str: "ase", A: -1, B: 2, F: nil},
	{Str: "iese", A: -1, B: 2, F: nil},
	{Str: "aste", A: -1, B: 2, F: nil},
	{Str: "iste", A: -1, B: 2, F: nil},
	{Str: "an", A: -1, B: 2, F: nil},
	{Str: "aban", A: 16, B: 2, F: nil},
	{Str: "aran", A: 16, B: 2, F: nil},
	{Str: "ieran", A: 16, B: 2, F: nil},
	{Str: "\u00EDan", A: 16, B: 2, F: nil},
	{Str: "ar\u00EDan", A: 20, B: 2, F: nil},
	{Str: "er\u00EDan", A: 20, B: 2, F: nil},
	{Str: "ir\u00EDan", A: 20, B: 2, F: nil},
	{Str: "en", A: -1, B: 1, F: nil},
	{Str: "asen", A: 24, B: 2, F: nil},
	{Str: "iesen", A: 24, B: 2, F: nil},
	{Str: "aron", A: -1, B: 2, F: nil},
	{Str: "ieron", A: -1, B: 2, F: nil},
	{Str: "ar\u00E1n", A: -1, B: 2, F: nil},
	{Str: "er\u00E1n", A: -1, B: 2, F: nil},
	{Str: "ir\u00E1n", A: -1, B: 2, F: nil},
	{Str: "ado", A: -1, B: 2, F: nil},
	{Str: "ido", A: -1, B: 2, F: nil},
	{Str: "ando", A: -1, B: 2, F: nil},
	{Str: "iendo", A: -1, B: 2, F: nil},
	{Str: "ar", A: -1, B: 2, F: nil},
	{Str: "er", A: -1, B: 2, F: nil},
	{Str: "ir", A: -1, B: 2, F: nil},
	{Str: "as", A: -1, B: 2, F: nil},
	{Str: "abas", A: 39, B: 2, F: nil},
	{Str: "adas", A: 39, B: 2, F: nil},
	{Str: "idas", A: 39, B: 2, F: nil},
	{Str: "aras", A: 39, B: 2, F: nil},
	{Str: "ieras", A: 39, B: 2, F: nil},
	{Str: "\u00EDas", A: 39, B: 2, F: nil},
	{Str: "ar\u00EDas", A: 45, B: 2, F: nil},
	{Str: "er\u00EDas", A: 45, B: 2, F: nil},
	{Str: "ir\u00EDas", A: 45, B: 2, F: nil},
	{Str: "es", A: -1, B: 1, F: nil},
	{Str: "ases", A: 49, B: 2, F: nil},
	{Str: "ieses", A: 49, B: 2, F: nil},
	{Str: "abais", A: -1, B: 2, F: nil},
	{Str: "arais", A: -1, B: 2, F: nil},
	{Str: "ierais", A: -1, B: 2, F: nil},
	{Str: "\u00EDais", A: -1, B: 2, F: nil},
	{Str: "ar\u00EDais", A: 55, B: 2, F: nil},
	{Str: "er\u00EDais", A: 55, B: 2, F: nil},
	{Str: "ir\u00EDais", A: 55, B: 2, F: nil},
	{Str: "aseis", A: -1, B: 2, F: nil},
	{Str: "ieseis", A: -1, B: 2, F: nil},
	{Str: "asteis", A: -1, B: 2, F: nil},
	{Str: "isteis", A: -1, B: 2, F: nil},
	{Str: "\u00E1is", A: -1, B: 2, F: nil},
	{Str: "\u00E9is", A: -1, B: 1, F: nil},
	{Str: "ar\u00E9is", A: 64, B: 2, F: nil},
	{Str: "er\u00E9is", A: 64, B: 2, F: nil},
	{Str: "ir\u00E9is", A: 64, B: 2, F: nil},
	{Str: "ados", A: -1, B: 2, F: nil},
	{Str: "idos", A: -1, B: 2, F: nil},
	{Str: "amos", A: -1, B: 2, F: nil},
	{Str: "\u00E1bamos", A: 70, B: 2, F: nil},
	{Str: "\u00E1ramos", A: 70, B: 2, F: nil},
	{Str: "i\u00E9ramos", A: 70, B: 2, F: nil},
	{Str: "\u00EDamos", A: 70, B: 2, F: nil},
	{Str: "ar\u00EDamos", A: 74, B: 2, F: nil},
	{Str: "er\u00EDamos", A: 74, B: 2, F: nil},
	{Str: "ir\u00EDamos", A: 74, B: 2, F: nil},
	{Str: "emos", A: -1, B: 1, F: nil},
	{Str: "aremos", A: 78, B: 2, F: nil},
	{Str: "eremos", A: 78, B: 2, F: nil},
	{Str: "iremos", A: 78, B: 2, F: nil},
	{Str: "\u00E1semos", A: 78, B: 2, F: nil},
	{Str: "i\u00E9semos", A: 78, B: 2, F: nil},
	{Str: "imos", A: -1, B: 2, F: nil},
	{Str: "ar\u00E1s", A: -1, B: 2, F: nil},
	{Str: "er\u00E1s", A: -1, B: 2, F: nil},
	{Str: "ir\u00E1s", A: -1, B: 2, F: nil},
	{Str: "\u00EDs", A: -1, B: 2, F: nil},
	{Str: "ar\u00E1", A: -1, B: 2, F: nil},
	{Str: "er\u00E1", A: -1, B: 2, F: nil},
	{Str: "ir\u00E1", A: -1, B: 2, F: nil},
	{Str: "ar\u00E9", A: -1, B: 2, F: nil},
	{Str: "er\u00E9", A: -1, B: 2, F: nil},
	{Str: "ir\u00E9", A: -1, B: 2, F: nil},
	{Str: "i\u00F3", A: -1, B: 2, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	{Str: "a", A: -1, B: 1, F: nil},
	{Str: "e", A: -1, B: 2, F: nil},
	{Str: "o", A: -1, B: 1, F: nil},
	{Str: "os", A: -1, B: 1, F: nil},
	{Str: "\u00E1", A: -1, B: 1, F: nil},
	{Str: "\u00E9", A: -1, B: 2, F: nil},
	{Str: "\u00ED", A: -1, B: 1, F: nil},
	{Str: "\u00F3", A: -1, B: 1, F: nil},
}

var G_v = []byte{17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 10}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	// (, line 31
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	// do, line 37
	var v_1 = env.Cursor
lab0:
	for {
		// (, line 37
		// or, line 39
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				// (, line 38
				if !env.InGrouping(G_v, 97, 252) {
					break lab2
				}
				// or, line 38
			lab3:
				for {
					var v_3 = env.Cursor
				lab4:
					for {
						// (, line 38
						if !env.OutGrouping(G_v, 97, 252) {
							break lab4
						}
						// gopast, line 38
					golab5:
						for {
						lab6:
							for {
								if !env.InGrouping(G_v, 97, 252) {
									break lab6
								}
								break golab5
							}
							if env.Cursor >= env.Limit {
								break lab4
							}
							env.NextChar()
						}
						break lab3
					}
					env.Cursor = v_3
					// (, line 38
					if !env.InGrouping(G_v, 97, 252) {
						break lab2
					}
					// gopast, line 38
				golab7:
					for {
					lab8:
						for {
							if !env.OutGrouping(G_v, 97, 252) {
								break lab8
							}
							break golab7
						}
						if env.Cursor >= env.Limit {
							break lab2
						}
						env.NextChar()
					}
					break lab3
				}
				break lab1
			}
			env.Cursor = v_2
			// (, line 40
			if !env.OutGrouping(G_v, 97, 252) {
				break lab0
			}
			// or, line 40
		lab9:
			for {
				var v_6 = env.Cursor
			lab10:
				for {
					// (, line 40
					if !env.OutGrouping(G_v, 97, 252) {
						break lab10
					}
					// gopast, line 40
				golab11:
					for {
					lab12:
						for {
							if !env.InGrouping(G_v, 97, 252) {
								break lab12
							}
							break golab11
						}
						if env.Cursor >= env.Limit {
							break lab10
						}
						env.NextChar()
					}
					break lab9
				}
				env.Cursor = v_6
				// (, line 40
				if !env.InGrouping(G_v, 97, 252) {
					break lab0
				}
				// next, line 40
				if env.Cursor >= env.Limit {
					break lab0
				}
				env.NextChar()
				break lab9
			}
			break lab1
		}
		// setmark pV, line 41
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	// do, line 43
	var v_8 = env.Cursor
lab13:
	for {
		// (, line 43
		// gopast, line 44
	golab14:
		for {
		lab15:
			for {
				if !env.InGrouping(G_v, 97, 252) {
					break lab15
				}
				break golab14
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 44
	golab16:
		for {
		lab17:
			for {
				if !env.OutGrouping(G_v, 97, 252) {
					break lab17
				}
				break golab16
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p1, line 44
		context.i_p1 = env.Cursor
		// gopast, line 45
	golab18:
		for {
		lab19:
			for {
				if !env.InGrouping(G_v, 97, 252) {
					break lab19
				}
				break golab18
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// gopast, line 45
	golab20:
		for {
		lab21:
			for {
				if !env.OutGrouping(G_v, 97, 252) {
					break lab21
				}
				break golab20
			}
			if env.Cursor >= env.Limit {
				break lab13
			}
			env.NextChar()
		}
		// setmark p2, line 45
		context.i_p2 = env.Cursor
		break lab13
	}
	env.Cursor = v_8
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// repeat, line 49
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			// (, line 49
			// [, line 50
			env.Bra = env.Cursor
			// substring, line 50
			among_var = env.FindAmong(A_0, context)
			if among_var == 0 {
				break lab1
			}
			// ], line 50
			env.Ket = env.Cursor
			if among_var == 0 {
				break lab1
			} else if among_var == 1 {
				// (, line 51
				// <-, line 51
				if !env.SliceFrom("a") {
					return false
				}
			} else if among_var == 2 {
				// (, line 52
				// <-, line 52
				if !env.SliceFrom("e") {
					return false
				}
			} else if among_var == 3 {
				// (, line 53
				// <-, line 53
				if !env.SliceFrom("i") {
					return false
				}
			} else if among_var == 4 {
				// (, line 54
				// <-, line 54
				if !env.SliceFrom("o") {
					return false
				}
			} else if among_var == 5 {
				// (, line 55
				// <-, line 55
				if !env.SliceFrom("u") {
					return false
				}
			} else if among_var == 6 {
				// (, line 57
				// next, line 57
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_pV <= env.Cursor) {
		return false
	}
	return true
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p1 <= env.Cursor) {
		return false
	}
	return true
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if !(context.i_p2 <= env.Cursor) {
		return false
	}
	return true
}

func r_attached_pronoun(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 67
	// [, line 68
	env.Ket = env.Cursor
	// substring, line 68
	if env.FindAmongB(A_1, context) == 0 {
		return false
	}
	// ], line 68
	env.Bra = env.Cursor
	// substring, line 72
	among_var = env.FindAmongB(A_2, context)
	if among_var == 0 {
		return false
	}
	// call RV, line 72
	if !r_RV(env, context) {
		return false
	}
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 73
		// ], line 73
		env.Bra = env.Cursor
		// <-, line 73
		if !env.SliceFrom("iendo") {
			return false
		}
	} else if among_var == 2 {
		// (, line 74
		// ], line 74
		env.Bra = env.Cursor
		// <-, line 74
		if !env.SliceFrom("ando") {
			return false
		}
	} else if among_var == 3 {
		// (, line 75
		// ], line 75
		env.Bra = env.Cursor
		// <-, line 75
		if !env.SliceFrom("ar") {
			return false
		}
	} else if among_var == 4 {
		// (, line 76
		// ], line 76
		env.Bra = env.Cursor
		// <-, line 76
		if !env.SliceFrom("er") {
			return false
		}
	} else if among_var == 5 {
		// (, line 77
		// ], line 77
		env.Bra = env.Cursor
		// <-, line 77
		if !env.SliceFrom("ir") {
			return false
		}
	} else if among_var == 6 {
		// (, line 81
		// delete, line 81
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 7 {
		// (, line 82
		// literal, line 82
		if !env.EqSB("u") {
			return false
		}
		// delete, line 82
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 86
	// [, line 87
	env.Ket = env.Cursor
	// substring, line 87
	among_var = env.FindAmongB(A_6, context)
	if among_var == 0 {
		return false
	}
	// ], line 87
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 98
		// call R2, line 99
		if !r_R2(env, context) {
			return false
		}
		// delete, line 99
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 104
		// call R2, line 105
		if !r_R2(env, context) {
			return false
		}
		// delete, line 105
		if !env.SliceDel() {
			return false
		}
		// try, line 106
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 106
			// [, line 106
			env.Ket = env.Cursor
			// literal, line 106
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// ], line 106
			env.Bra = env.Cursor
			// call R2, line 106
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// delete, line 106
			if !env.SliceDel() {
				return false
			}
			break lab0
		}
	} else if among_var == 3 {
		// (, line 110
		// call R2, line 111
		if !r_R2(env, context) {
			return false
		}
		// <-, line 111
		if !env.SliceFrom("log") {
			return false
		}
	} else if among_var == 4 {
		// (, line 114
		// call R2, line 115
		if !r_R2(env, context) {
			return false
		}
		// <-, line 115
		if !env.SliceFrom("u") {
			return false
		}
	} else if among_var == 5 {
		// (, line 118
		// call R2, line 119
		if !r_R2(env, context) {
			return false
		}
		// <-, line 119
		if !env.SliceFrom("ente") {
			return false
		}
	} else if among_var == 6 {
		// (, line 122
		// call R1, line 123
		if !r_R1(env, context) {
			return false
		}
		// delete, line 123
		if !env.SliceDel() {
			return false
		}
		// try, line 124
		var v_2 = env.Limit - env.Cursor
	lab1:
		for {
			// (, line 124
			// [, line 125
			env.Ket = env.Cursor
			// substring, line 125
			among_var = env.FindAmongB(A_3, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			// ], line 125
			env.Bra = env.Cursor
			// call R2, line 125
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_2
				break lab1
			}
			// delete, line 125
			if !env.SliceDel() {
				return false
			}
			if among_var == 0 {
				env.Cursor = env.Limit - v_2
				break lab1
			} else if among_var == 1 {
				// (, line 126
				// [, line 126
				env.Ket = env.Cursor
				// literal, line 126
				if !env.EqSB("at") {
					env.Cursor = env.Limit - v_2
					break lab1
				}
				// ], line 126
				env.Bra = env.Cursor
				// call R2, line 126
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_2
					break lab1
				}
				// delete, line 126
				if !env.SliceDel() {
					return false
				}
			}
			break lab1
		}
	} else if among_var == 7 {
		// (, line 134
		// call R2, line 135
		if !r_R2(env, context) {
			return false
		}
		// delete, line 135
		if !env.SliceDel() {
			return false
		}
		// try, line 136
		var v_3 = env.Limit - env.Cursor
	lab2:
		for {
			// (, line 136
			// [, line 137
			env.Ket = env.Cursor
			// substring, line 137
			among_var = env.FindAmongB(A_4, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab2
			}
			// ], line 137
			env.Bra = env.Cursor
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab2
			} else if among_var == 1 {
				// (, line 140
				// call R2, line 140
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab2
				}
				// delete, line 140
				if !env.SliceDel() {
					return false
				}
			}
			break lab2
		}
	} else if among_var == 8 {
		// (, line 146
		// call R2, line 147
		if !r_R2(env, context) {
			return false
		}
		// delete, line 147
		if !env.SliceDel() {
			return false
		}
		// try, line 148
		var v_4 = env.Limit - env.Cursor
	lab3:
		for {
			// (, line 148
			// [, line 149
			env.Ket = env.Cursor
			// substring, line 149
			among_var = env.FindAmongB(A_5, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_4
				break lab3
			}
			// ], line 149
			env.Bra = env.Cursor
			if among_var == 0 {
				env.Cursor = env.Limit - v_4
				break lab3
			} else if among_var == 1 {
				// (, line 152
				// call R2, line 152
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_4
					break lab3
				}
				// delete, line 152
				if !env.SliceDel() {
					return false
				}
			}
			break lab3
		}
	} else if among_var == 9 {
		// (, line 158
		// call R2, line 159
		if !r_R2(env, context) {
			return false
		}
		// delete, line 159
		if !env.SliceDel() {
			return false
		}
		// try, line 160
		var v_5 = env.Limit - env.Cursor
	lab4:
		for {
			// (, line 160
			// [, line 161
			env.Ket = env.Cursor
			// literal, line 161
			if !env.EqSB("at") {
				env.Cursor = env.Limit - v_5
				break lab4
			}
			// ], line 161
			env.Bra = env.Cursor
			// call R2, line 161
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_5
				break lab4
			}
			// delete, line 161
			if !env.SliceDel() {
				return false
			}
			break lab4
		}
	}
	return true
}

func r_y_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 167
	// setlimit, line 168
	var v_1 = env.Limit - env.Cursor
	// tomark, line 168
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 168
	// [, line 168
	env.Ket = env.Cursor
	// substring, line 168
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 168
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 171
		// literal, line 171
		if !env.EqSB("u") {
			return false
		}
		// delete, line 171
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 175
	// setlimit, line 176
	var v_1 = env.Limit - env.Cursor
	// tomark, line 176
	if env.Cursor < context.i_pV {
		return false
	}
	env.Cursor = context.i_pV
	var v_2 = env.LimitBackward
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit - v_1
	// (, line 176
	// [, line 176
	env.Ket = env.Cursor
	// substring, line 176
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		env.LimitBackward = v_2
		return false
	}
	// ], line 176
	env.Bra = env.Cursor
	env.LimitBackward = v_2
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 179
		// try, line 179
		var v_3 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 179
			// literal, line 179
			if !env.EqSB("u") {
				env.Cursor = env.Limit - v_3
				break lab0
			}
			// test, line 179
			var v_4 = env.Limit - env.Cursor
			// literal, line 179
			if !env.EqSB("g") {
				env.Cursor = env.Limit - v_3
				break lab0
			}
			env.Cursor = env.Limit - v_4
			break lab0
		}
		// ], line 179
		env.Bra = env.Cursor
		// delete, line 179
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 200
		// delete, line 200
		if !env.SliceDel() {
			return false
		}
	}
	return true
}

func r_residual_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	// (, line 204
	// [, line 205
	env.Ket = env.Cursor
	// substring, line 205
	among_var = env.FindAmongB(A_9, context)
	if among_var == 0 {
		return false
	}
	// ], line 205
	env.Bra = env.Cursor
	if among_var == 0 {
		return false
	} else if among_var == 1 {
		// (, line 208
		// call RV, line 208
		if !r_RV(env, context) {
			return false
		}
		// delete, line 208
		if !env.SliceDel() {
			return false
		}
	} else if among_var == 2 {
		// (, line 210
		// call RV, line 210
		if !r_RV(env, context) {
			return false
		}
		// delete, line 210
		if !env.SliceDel() {
			return false
		}
		// try, line 210
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			// (, line 210
			// [, line 210
			env.Ket = env.Cursor
			// literal, line 210
			if !env.EqSB("u") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// ], line 210
			env.Bra = env.Cursor
			// test, line 210
			var v_2 = env.Limit - env.Cursor
			// literal, line 210
			if !env.EqSB("g") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			env.Cursor = env.Limit - v_2
			// call RV, line 210
			if !r_RV(env, context) {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			// delete, line 210
			if !env.SliceDel() {
				return false
			}
			break lab0
		}
	}
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	// (, line 215
	// do, line 216
	var v_1 = env.Cursor
lab0:
	for {
		// call mark_regions, line 216
		if !r_mark_regions(env, context) {
			break lab0
		}
		break lab0
	}
	env.Cursor = v_1
	// backwards, line 217
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	// (, line 217
	// do, line 218
	var v_2 = env.Limit - env.Cursor
lab1:
	for {
		// call attached_pronoun, line 218
		if !r_attached_pronoun(env, context) {
			break lab1
		}
		break lab1
	}
	env.Cursor = env.Limit - v_2
	// do, line 219
	var v_3 = env.Limit - env.Cursor
lab2:
	for {
		// (, line 219
		// or, line 219
	lab3:
		for {
			var v_4 = env.Limit - env.Cursor
		lab4:
			for {
				// call standard_suffix, line 219
				if !r_standard_suffix(env, context) {
					break lab4
				}
				break lab3
			}
			env.Cursor = env.Limit - v_4
		lab5:
			for {
				// call y_verb_suffix, line 220
				if !r_y_verb_suffix(env, context) {
					break lab5
				}
				break lab3
			}
			env.Cursor = env.Limit - v_4
			// call verb_suffix, line 221
			if !r_verb_suffix(env, context) {
				break lab2
			}
			break lab3
		}
		break lab2
	}
	env.Cursor = env.Limit - v_3
	// do, line 223
	var v_5 = env.Limit - env.Cursor
lab6:
	for {
		// call residual_suffix, line 223
		if !r_residual_suffix(env, context) {
			break lab6
		}
		break lab6
	}
	env.Cursor = env.Limit - v_5
	env.Cursor = env.LimitBackward
	// do, line 225
	var v_6 = env.Cursor
lab7:
	for {
		// call postlude, line 225
		if !r_postlude(env, context) {
			break lab7
		}
		break lab7
	}
	env.Cursor = v_6
	return true
}
